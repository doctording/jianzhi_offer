<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Java IO基础 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_io_net">java_io_net</a>&nbsp;&#187;&nbsp;Java IO基础
    <span class="updated">Page Updated&nbsp;
      2019-03-18 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Java IO基础</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#java-io">Java IO 基础</a></li>
<li><a href="#how-java-io-works-internally-at-lower-level">How Java I/O Works Internally at Lower Level?</a><ul>
<li><a href="#_1">缓冲区</a></li>
<li><a href="#_2">缓冲流</a></li>
<li><a href="#_3">用户空间,内核空间,磁盘</a></li>
<li><a href="#io">文件IO</a><ul>
<li><a href="#_4">系统调用和文件读写</a></li>
<li><a href="#io_1">用户I/O缓冲区的类型</a></li>
<li><a href="#_5">用户空间 &amp; 内核空间</a><ul>
<li><a href="#_6">为什么不直接 让磁盘控制器把数据送到用户空间的缓冲区呢?</a></li>
<li><a href="#vfs">vfs(虚拟文件系统)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#io_2">IO模型：同步/阻塞概念</a><ul>
<li><a href="#io_3">阻塞与非阻塞(等待IO时的状态)</a></li>
<li><a href="#_7">同步与异步（用户线程与内核的消息交互方式）</a></li>
<li><a href="#_8">用水壶烧水的例子说明[同步/阻塞]</a></li>
<li><a href="#io_4">网络IO模型演进</a><ul>
<li><a href="#bioblocking-io-io">传统的BIO(Blocking I/O 阻塞IO)</a><ul>
<li><a href="#selectornio-single-thread">selector(NIO Single Thread 模型)</a></li>
</ul>
</li>
<li><a href="#nio-reactor">NIO reactor模式（多线程轮询）</a></li>
<li><a href="#aioio">AIO（异步IO）</a></li>
</ul>
</li>
<li><a href="#io_5">IO复用</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="java-io">Java IO 基础</h1>
<p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，<strong>流的本质是数据传输</strong>，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<ul>
<li>字节流 InputStream/OutStream</li>
</ul>
<p>字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p>
<ul>
<li>字符流 Reader/Writer</li>
</ul>
<h1 id="how-java-io-works-internally-at-lower-level">How Java I/O Works Internally at Lower Level?</h1>
<h2 id="_1">缓冲区</h2>
<p>计算机访问外部设备或文件，要比直接访问内存慢的多。如果我们每次调用<code>read()</code>方法或者<code>write()</code>方法访问外部的设备或文件，CPU就要花上最多的时间是在等外部设备响应，而不是数据处理。为此，我们开辟一个内存缓冲区的内存区域，程序每次调用<code>read()</code>方法或<code>write()</code>方法都是读写在这个缓冲区中。当这个缓冲区被装满后，系统才将这个缓冲区的内容一次集中写到外部设备或读取进来给CPU。使用缓冲区可以有效的提高CPU的使用率，能提高整个计算机系统的效率。在字符流操作中，所有的字符都是在内存中形成的，在字符流输出前都将保存在内存中的缓冲区内。</p>
<h2 id="_2">缓冲流</h2>
<p>在读写数据时，让数据在缓冲区能减少系统实际对原始数据来源的存取次数，因为一次能做多个数据单位的操作，相较而言，对于从文件读取数据或将数据写入文件，比起缓冲区的读写要慢多了。所以使用有缓冲区的流，一般都会比没有缓冲区的流效率更高，拥有缓冲区的流别称为缓冲流，包括BufferedInputStream、BufferedOutputStream类和BufferedReader、BufferedWriter类。缓冲流把数据从原始流成块读入或把数据积累到一个大数据块后再成批写出，通过减少通过资源的读写次数来加快程序的执行</p>
<h2 id="_3">用户空间,内核空间,磁盘</h2>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io_net/imgs/io_buffer.png" /></p>
<p>在磁盘空间和用户空间中加一个内核空间的缓存区的原因有两个：</p>
<ol>
<li>一个是用户空间的程序不能直接去磁盘空间中读取数据，必须由经由内核空间通过DMA来获取;</li>
<li>另一个原因是一般用户空间的内存分页与磁盘空间不会对齐，因此需要由内核空间在中间做一层处理。</li>
</ol>
<p>目前的操作系统，用户空间和内核空间的区分一般采用虚拟内存来实现，因此用户空间和内存空间都是在虚拟内存中。使用虚拟内存无非是因为其两大优势：一是它可以使多个虚拟内存地址指向同一个物理内存;二是虚拟内存的空间可以大于物理内存的空间。</p>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io_net/imgs/io_buffer_virtual.png" /></p>
<ul>
<li>
<p>当用户空间所需要的数据在内核空间中已经存在，那么内核无需再次向磁盘控制硬件发起<code>系统调用</code>，直接<strong>对内核缓冲区进行复制</strong>，这些数据成为高速缓存，当然内核也可以预读取用户空间需要的数据。</p>
</li>
<li>
<p>用户空间通常是常规进程所在区域，即非特权区域，不能直接访问磁盘硬件设备；</p>
</li>
<li>
<p>使用虚拟内存<strong>省去了用户空间和内存空间的数据往来拷贝</strong>，但缓冲区的大小必须是磁盘数据块的倍数，用户空间和内核空间也必须使用相同的页对其方式。</p>
</li>
</ul>
<h2 id="io">文件IO</h2>
<p>文件系统是安排、解释磁盘数据的一种独特方式，文件系统定义了文件名、路径、文件、文件属性等一系列抽象概念。</p>
<p>当用户进程请求文件数据时，文件系统需要确定数据在磁盘什么位置，然后将相关磁盘分区读进内存。</p>
<h3 id="_4">系统调用和文件读写</h3>
<p>应用程序代码运行在用户模式下，当应用程序需要实现内核模式下的指令时，先向操作系统发送调用请求。操作系统收到请求后，执行系统调用接口，使处理器进入内核模式。当处理器处理完系统调用操作后，操作系统会让处理器返回用户模式，继续执行用户代码。</p>
<div class="hlcode"><pre><span class="err">用户态</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="err">系统调用</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="err">内核态</span>
                            <span class="err">\</span>
                             <span class="err">磁盘</span>
                            <span class="o">/</span>
    <span class="err">用户态</span><span class="n">IO</span><span class="err">缓冲区</span>   <span class="o">&lt;-</span>  <span class="err">内核缓冲区域</span>
</pre></div>


<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io_net/imgs/fill_call.png" /></p>
<h3 id="io_1">用户I/O缓冲区的类型</h3>
<ul>
<li>全缓冲</li>
</ul>
<p>此种类型的缓冲只有在缓冲区满的时候才会调用实际的文件 IO 进入内核态操作。除了涉及到终端设备文件的流，其它文件流默认基本都是全缓冲。</p>
<ul>
<li>行缓冲</li>
</ul>
<p>此种类型的缓冲在缓冲区满或者遇到 <code>\n</code> 的时候才会调用实际的文件 IO 进入内核态操作。当流涉及到终端设备的时候就是行缓冲，比如标准输入流和标准输出流。如果对标准输入流或者输出流进行重定向到某个文件的时候，该流就是全缓冲的。</p>
<ul>
<li>无缓冲</li>
</ul>
<p>没有缓冲区。直接调用文件 IO 进入内核态操作。标准错误流默认就是无缓冲的。</p>
<h3 id="_5">用户空间 &amp; 内核空间</h3>
<p>用户空间是常规进程所在区域。<code>JVM</code>就是常规进程，驻守于用户空间。用户空间是非特权区域:比如，在该区域执行的代码就不能直接访问硬件设备。内核空间是操作系统所在区域。内核代码有特别的权力:它能与设备控制器通讯，控制着用户区域 进程的运行状态，等等。最重要的是，所有<code>I/O</code>都直接或间接通过内核空间。</p>
<p>当进程请求<code>I/O</code>操作的时候，它执行一个系统调用(有时称为陷阱)将控制权移交给内核。C/C++程序员所熟知的底层函数<code>open()</code>、<code>read()</code>、<code>write()</code>和<code>close()</code>要做的无非就是建立和执行适当的<code>系统调用</code>。当内核以这种方式被调用，它随即采取任何必要步骤，找到进程所需数据，并把数据 传送到用户空间内的指定缓冲区。内核试图对数据进行高速缓存或预读取，因此进程所需数据可能 已经在内核空间里了。如果是这样，该数据只需简单地拷贝出来即可。如果数据不在内核空间，则 进程被挂起，内核要把数据读进内存。</p>
<p><strong>内核缓冲区</strong>的主要思想就是：一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据。</p>
<h4 id="_6">为什么不直接 让磁盘控制器把数据送到用户空间的缓冲区呢?</h4>
<ul>
<li>硬件通常不能直接访问 用户空间；硬件设备通常不能直接使用虚拟内存地址</li>
<li>像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请 求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责 数据的分解、再组合工作，因此充当着中间人的角色</li>
</ul>
<h4 id="vfs">vfs(虚拟文件系统)</h4>
<p>虚拟文件系统(VFS)是由Sun microsystems公司在定义网络文件系统(NFS)时创造的。它是一种用于网络环境的分布式文件系统，是允许和操作系统使用不同的文件系统实现的接口。虚拟文件系统（VFS）是物理文件系统与服务之间的一个接口层，它对Linux的每个文件系统的所有细节进行抽象，使得不同的文件系统在Linux核心以及系统中运行的其他进程看来，都是相同的。严格说来，VFS并不是一种实际的文件系统。它只存在于内存中，不存在于任何外存空间。VFS在系统启动时建立，在系统关闭时消亡。</p>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io_net/imgs/vfs.png" /></p>
<h1 id="io_2">IO模型：同步/阻塞概念</h1>
<h2 id="io_3">阻塞与非阻塞(等待IO时的状态)</h2>
<p>函数或方法（用户线程调用内核IO操作）的实现方式：</p>
<ul>
<li>阻塞是指IO操作需要彻底完成后才返回到用户空间</li>
<li>非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</li>
</ul>
<h2 id="_7">同步与异步（用户线程与内核的消息交互方式）</h2>
<ul>
<li>
<p>同步指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；同步有阻塞，非阻塞之分</p>
</li>
<li>
<p>异步是指用户线程发起IO请求后仍然继续执行，当<strong>内核IO操作完成后会通知用户线程</strong>，或者调用用户线程注册的回调函数。异步一定是非阻塞的（内核会通过函数回调或者信号机制通知用户进程；类似观察者模式）</p>
</li>
</ul>
<h2 id="_8">用水壶烧水的例子说明[同步/阻塞]</h2>
<ul>
<li>
<p>同步阻塞</p>
</li>
<li>
<p>点火(发消息)</p>
</li>
<li>搬个小板凳盯着水壶(傻等，眼睛不动)，不等到水壶烧开水，坚决不去做别的事情（阻塞）</li>
</ul>
<p>用户线程的IO处理过程需要等待，中间不能做任何事情，对CPU利用率很低</p>
<ul>
<li>
<p>同步非阻塞</p>
</li>
<li>
<p>点火(发消息)</p>
</li>
<li>去看会儿电视，时不时过来(轮询)看水壶烧开水没有（非阻塞);水开后接着处理</li>
</ul>
<p>用户线程每次IO请求都能立刻返回，但需要通过轮询去判断数据是否返回，会无谓地消耗大量的CPU</p>
<ul>
<li>
<p>异步阻塞（很少发生）</p>
</li>
<li>
<p>点火(发消息)</p>
</li>
<li>水壶有个响铃，自动绑定了开水之后的处理程序，这样响铃之后自动处理(异步)</li>
<li>
<p>但是还是可以轮询去看水壶开了没有</p>
</li>
<li>
<p>异步非阻塞</p>
</li>
<li>
<p>点火(发消息), 写好水壶烧开水之后的处理程序</p>
</li>
<li>水壶有个响铃，自动绑定了开水之后的处理程序，这样响铃之后自动处理</li>
<li>人该干嘛干嘛去，不用管了（不用傻等，不用轮询）</li>
</ul>
<h2 id="io_4">网络IO模型演进</h2>
<h3 id="bioblocking-io-io">传统的<code>BIO</code>(Blocking I/O 阻塞IO)</h3>
<ul>
<li>server</li>
</ul>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">ServerSocket</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">();</span>
        <span class="n">ss</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="n">InetSocketAddress</span><span class="o">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="o">,</span> <span class="mi">8888</span><span class="o">));</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Socket</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span> <span class="c1">//阻塞方法</span>

            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">handle</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Socket</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">().</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">));</span>

            <span class="n">s</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
            <span class="n">s</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">flush</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>client</li>
</ul>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">Socket</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Socket</span><span class="o">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="o">,</span> <span class="mi">8888</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="s">&quot;HelloServer&quot;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="n">s</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">flush</span><span class="o">();</span>
        <span class="c1">//s.getOutputStream().close();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;write over, waiting for msg back...&quot;</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">().</span><span class="na">read</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">));</span>
        <span class="n">s</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>Server端的<code>accept</code>方法是阻塞的，等待客户端来连接</li>
<li>用一个线程建立连接后，输入/输出流的读写过程是阻塞的</li>
</ul>
<p><font color='red'>效率低，并发不高，线程开销大</font></p>
<h4 id="selectornio-single-thread">selector(NIO Single Thread 模型)</h4>
<p><font color='red'>不同的事情(有客户端来连接，有输入/输出的读写事件)进行轮训监听，该线程负责所有的这些工作</font></p>
<ul>
<li>Server</li>
</ul>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">ServerSocketChannel</span> <span class="n">ssc</span> <span class="o">=</span> <span class="n">ServerSocketChannel</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
        <span class="n">ssc</span><span class="o">.</span><span class="na">socket</span><span class="o">().</span><span class="na">bind</span><span class="o">(</span><span class="k">new</span> <span class="n">InetSocketAddress</span><span class="o">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="o">,</span> <span class="mi">8888</span><span class="o">));</span>
        <span class="n">ssc</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;server started, listening on :&quot;</span> <span class="o">+</span> <span class="n">ssc</span><span class="o">.</span><span class="na">getLocalAddress</span><span class="o">());</span>
        <span class="n">Selector</span> <span class="n">selector</span> <span class="o">=</span> <span class="n">Selector</span><span class="o">.</span><span class="na">open</span><span class="o">();</span>
        <span class="c1">// selector 注册感兴趣的事情：连接时间</span>
        <span class="n">ssc</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">selector</span><span class="o">,</span> <span class="n">SelectionKey</span><span class="o">.</span><span class="na">OP_ACCEPT</span><span class="o">);</span>

        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 阻塞</span>
            <span class="n">selector</span><span class="o">.</span><span class="na">select</span><span class="o">();</span>
            <span class="n">Set</span><span class="o">&lt;</span><span class="n">SelectionKey</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="na">selectedKeys</span><span class="o">();</span>
            <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">SelectionKey</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
            <span class="k">while</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">SelectionKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
                <span class="n">it</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
                <span class="c1">// 处理这个事件</span>
                <span class="n">handle</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">SelectionKey</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isAcceptable</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">ServerSocketChannel</span> <span class="n">ssc</span> <span class="o">=</span> <span class="o">(</span><span class="n">ServerSocketChannel</span><span class="o">)</span> <span class="n">key</span><span class="o">.</span><span class="na">channel</span><span class="o">();</span>
                <span class="n">SocketChannel</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">ssc</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
                <span class="n">sc</span><span class="o">.</span><span class="na">configureBlocking</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                <span class="c1">//new Client</span>
                <span class="c1">//</span>
                <span class="c1">//String hostIP = ((InetSocketAddress)sc.getRemoteAddress()).getHostString();</span>

            <span class="cm">/*</span>
<span class="cm">            log.info(&quot;client &quot; + hostIP + &quot; trying  to connect&quot;);</span>
<span class="cm">            for(int i=0; i&lt;clients.size(); i++) {</span>
<span class="cm">                String clientHostIP = clients.get(i).clientAddress.getHostString();</span>
<span class="cm">                if(hostIP.equals(clientHostIP)) {</span>
<span class="cm">                    log.info(&quot;this client has already connected! is he alvie &quot; + clients.get(i).live);</span>
<span class="cm">                    sc.close();</span>
<span class="cm">                    return;</span>
<span class="cm">                }</span>
<span class="cm">            }*/</span>

                <span class="n">sc</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">selector</span><span class="o">(),</span> <span class="n">SelectionKey</span><span class="o">.</span><span class="na">OP_READ</span> <span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">isReadable</span><span class="o">())</span> <span class="o">{</span> <span class="c1">//flip</span>
            <span class="n">SocketChannel</span> <span class="n">sc</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">sc</span> <span class="o">=</span> <span class="o">(</span><span class="n">SocketChannel</span><span class="o">)</span><span class="n">key</span><span class="o">.</span><span class="na">channel</span><span class="o">();</span>
                <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">512</span><span class="o">);</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>

                <span class="k">if</span><span class="o">(</span><span class="n">len</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">array</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">));</span>
                <span class="o">}</span>

                <span class="n">ByteBuffer</span> <span class="n">bufferToWrite</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="s">&quot;HelloClient&quot;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
                <span class="n">sc</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bufferToWrite</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">sc</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">sc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3 id="nio-reactor">NIO reactor模式（多线程轮询）</h3>
<p>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</p>
<p>(基于事件驱动，有一个Service Handler，处理一个或多个并发输入源，同步的分发给不同的Request Handlers)</p>
<ol>
<li>基于事件驱动-&gt; selector（支持对多个socketChannel的监听）</li>
<li>统一的事件分派中心-&gt; dispatch</li>
<li>事件处理服务-&gt; read &amp; write</li>
</ol>
<h3 id="aioio">AIO（异步IO）</h3>
<ul>
<li>
<p>NIO是同步的非阻塞,AIO是异步非阻塞的；</p>
</li>
<li>
<p>事件通知，而不是轮询</p>
</li>
</ul>
<p>但是AIO,NIO在linux下都是基于<code>epoll</code>（轮询）的, 所以netty对nio封装，但是API更像是AIO</p>
<h2 id="io_5">IO复用</h2>
<ol>
<li>
<p>等待数据准备好（waiting for data to be ready）。对于一个套接口上的操作，这一步骤关系到数据从网络到达，并将其复制到内核的某个缓冲区。</p>
</li>
<li>
<p>将数据从内核缓冲区复制到进程缓冲区（copying the data from the kernel to the process）</p>
</li>
</ol>
<p><strong>IO多路复用</strong>是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。I</p>
<h3 id="select">select</h3>
<p>Select是通过将需要监听的文件描述符加入相应的文件描述符集合(readset、writeset，exceptset)，由内核负责监视相应的文件描述符是否就绪。</p>
<p>目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，但select有如下的一些局限</p>
<ul>
<li>select监控的文件描述符有上限</li>
<li>每次调用都需要手动的设置文件描述符集合，使用非常不便</li>
<li>每次调用都要把文件描述符从用户态拷贝到内核态，开销比较大</li>
<li>当就绪的文件描述符好后，需要<strong>循环遍历</strong>来进行判断，效率不高</li>
</ul>
<p><code>linux select</code>服务端例子代码</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">server_sockfd</span><span class="p">,</span> <span class="n">client_sockfd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">server_len</span><span class="p">,</span> <span class="n">client_len</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server_address</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client_address</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">fd_set</span> <span class="n">readfds</span><span class="p">,</span> <span class="n">testfds</span><span class="p">;</span>
    <span class="n">server_sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//建立服务器端socket</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">8888</span><span class="p">);</span>
    <span class="n">server_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_address</span><span class="p">);</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_address</span><span class="p">,</span> <span class="n">server_len</span><span class="p">);</span>
    <span class="n">listen</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">//监听队列最多容纳5个</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
    <span class="n">FD_SET</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span><span class="c1">//将服务器端socket加入到集合中</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nread</span><span class="p">;</span>
        <span class="n">testfds</span> <span class="o">=</span> <span class="n">readfds</span><span class="p">;</span><span class="c1">//将需要监视的描述符集copy到select查询队列中，select会对其修改，所以一定要分开使用变量</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;server waiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

        <span class="cm">/*无限期阻塞，并测试文件描述符变动 */</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">FD_SETSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">testfds</span><span class="p">,</span> <span class="p">(</span><span class="n">fd_set</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">fd_set</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//FD_SETSIZE：系统默认的最大文件描述符</span>
        <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;server5&quot;</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/*扫描所有的文件描述符*/</span>
        <span class="k">for</span><span class="p">(</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="n">FD_SETSIZE</span><span class="p">;</span> <span class="n">fd</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/*找到相关文件描述符*/</span>
            <span class="k">if</span><span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">testfds</span><span class="p">))</span>
            <span class="p">{</span>
              <span class="cm">/*判断是否为服务器套接字，是则表示为客户请求连接。*/</span>
                <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="n">server_sockfd</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">client_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_address</span><span class="p">);</span>
                    <span class="n">client_sockfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span>
                    <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_len</span><span class="p">);</span>
                    <span class="n">FD_SET</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span><span class="c1">//将客户端socket加入到集合中</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;adding client on fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">client_sockfd</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="cm">/*客户端socket中有数据请求时*/</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIONREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nread</span><span class="p">);</span><span class="c1">//取得数据量交给nread</span>

                    <span class="cm">/*客户数据请求完毕，关闭套接字，从集合中清除相应描述符 */</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
                        <span class="n">FD_CLR</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span> <span class="c1">//去掉关闭的fd</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;removing client on fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="cm">/*处理客户数据请求*/</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                        <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;serving client on fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
                        <span class="n">ch</span><span class="o">++</span><span class="p">;</span>
                        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="poll">poll</h3>
<p>poll() 的机制与 select() 类似，与 select() 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理。</p>
<ul>
<li>
<p>优点</p>
</li>
<li>
<p>poll() 不要求开发者计算最大文件描述符加一的大小</p>
</li>
<li>poll() 在应付大数目的文件描述符的时候速度更快，相比于select</li>
<li>它没有最大连接数的限制，原因是它是基于链表来存储的</li>
<li>
<p>在调用函数时，只需要对参数进行一次设置就好了</p>
</li>
<li>
<p>缺点</p>
</li>
<li>
<p>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义</p>
</li>
<li>与select一样，poll返回后，需要轮询pollfd来获取就绪的描述符，这样会使性能下降</li>
<li>同时连接的大量客户端在一时刻可能只有很少的就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降</li>
</ul>
<h3 id="epoll">epoll</h3>
<p><a href="https://github.com/doctording/linux_epoll">epoll linux例子程序</a></p>
<ol>
<li>epoll是一个I/O管理组件</li>
<li>select 和 poll 的升级版本</li>
<li>怎么用，用在什么地方</li>
</ol>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io_net/imgs/epoll.png" /></p>
<ul>
<li><code>linux epoll 服务端</code>例子</li>
</ul>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">//服务器IP + port</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serverAddr</span><span class="p">;</span>
    <span class="n">serverAddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
    <span class="n">serverAddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">SERVER_PORT</span><span class="p">);</span>
    <span class="n">serverAddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">SERVER_IP</span><span class="p">);</span>
    <span class="c1">//创建监听socket</span>
    <span class="kt">int</span> <span class="n">listener</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">listener</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">perror</span><span class="p">(</span><span class="s">&quot;listener&quot;</span><span class="p">);</span> <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;listen socket created </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="c1">//绑定地址</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">bind</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serverAddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serverAddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;bind error&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//监听</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">perror</span><span class="p">(</span><span class="s">&quot;listen error&quot;</span><span class="p">);</span> <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Start to listen: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SERVER_IP</span><span class="p">);</span>
    <span class="c1">//在内核中创建事件表</span>
    <span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="n">EPOLL_SIZE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">epfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">perror</span><span class="p">(</span><span class="s">&quot;epfd error&quot;</span><span class="p">);</span> <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;epoll created, epollfd = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">epfd</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="n">EPOLL_SIZE</span><span class="p">];</span>
    <span class="c1">//往内核事件表里添加事件</span>
    <span class="n">addfd</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">listener</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="c1">//主循环</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//epoll_events_count表示就绪事件的数目</span>
        <span class="kt">int</span> <span class="n">epoll_events_count</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">EPOLL_SIZE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">epoll_events_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;epoll failure&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;epoll_events_count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">epoll_events_count</span><span class="p">);</span>
        <span class="c1">//处理这epoll_events_count个就绪事件</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">epoll_events_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
            <span class="c1">//新用户连接</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">==</span> <span class="n">listener</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client_address</span><span class="p">;</span>
                <span class="kt">socklen_t</span> <span class="n">client_addrLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">clientfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span> <span class="n">listener</span><span class="p">,</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span> <span class="p">)</span><span class="o">&amp;</span><span class="n">client_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_addrLength</span> <span class="p">);</span>

                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;client connection from: %s : % d(IP : port), clientfd = %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">inet_ntoa</span><span class="p">(</span><span class="n">client_address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">),</span>
                <span class="n">ntohs</span><span class="p">(</span><span class="n">client_address</span><span class="p">.</span><span class="n">sin_port</span><span class="p">),</span>
                <span class="n">clientfd</span><span class="p">);</span>

                <span class="n">addfd</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">clientfd</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

                <span class="c1">// 服务端用list保存用户连接</span>
                <span class="n">clients_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">clientfd</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Add new clientfd = %d to epoll</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clientfd</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Now there are %d clients int the chat room</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">clients_list</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

                <span class="c1">// 服务端发送欢迎信息  </span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;welcome message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>                
                <span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
                <span class="n">bzero</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
                <span class="n">sprintf</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">SERVER_WELCOME</span><span class="p">,</span> <span class="n">clientfd</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">send</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">perror</span><span class="p">(</span><span class="s">&quot;send error&quot;</span><span class="p">);</span> <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">//处理用户发来的消息，并广播，使其他用户收到信息</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sendBroadcastmessage</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">perror</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">listener</span><span class="p">);</span> <span class="c1">//关闭socket</span>
    <span class="n">close</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>    <span class="c1">//关闭内核</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-07-16 22:52:09</p>
      </span>
    </div>

    
    
  </body>
</html>