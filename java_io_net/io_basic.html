<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Java io基础 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_io_net">java_io_net</a>&nbsp;&#187;&nbsp;Java io基础
    <span class="updated">Page Updated&nbsp;
      2019-03-18 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Java io基础</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#java-io">Java IO 基础</a></li>
<li><a href="#how-java-io-works-internally-at-lower-level">How Java I/O Works Internally at Lower Level?</a><ul>
<li><a href="#_1">缓冲区</a></li>
<li><a href="#_2">缓冲流</a></li>
<li><a href="#_3">用户空间,内核空间,磁盘</a></li>
<li><a href="#io">文件IO</a><ul>
<li><a href="#_4">内存映射文件(用户内存到文件系统页的映射)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#io_1">IO模型</a><ul>
<li><a href="#_5">阻塞与非阻塞</a></li>
<li><a href="#_6">同步与异步</a></li>
<li><a href="#io_2">常见网络IO模型</a><ul>
<li><a href="#_7">同步阻塞</a></li>
<li><a href="#_8">同步非阻塞</a></li>
<li><a href="#io_3">IO复用</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a></li>
</ul>
</li>
<li><a href="#iosignal-blocking-io">信号驱动IO（signal blocking I/O）</a></li>
</ul>
</li>
<li><a href="#_9">用户空间 &amp; 内核空间</a><ul>
<li><a href="#_10">为什么不直接 让磁盘控制器把数据送到用户空间的缓冲区呢?</a></li>
</ul>
</li>
<li><a href="#33">3.3 虚拟内存</a><ul>
<li><a href="#_11">同时将多个进程保存在内存中以便允许多道程序设计？（最初的目标）</a><ul>
<li><a href="#_12">一次性</a></li>
<li><a href="#_13">驻留性</a></li>
</ul>
</li>
<li><a href="#_14">局部性原理(虚拟内存技术实现的条件)</a><ul>
<li><a href="#_15">时间局部性</a></li>
<li><a href="#_16">空间局部性</a></li>
</ul>
</li>
<li><a href="#_17">局部性原理=&gt;虚拟存储器</a></li>
<li><a href="#_18">虚拟内存技术的实现 和 面临的实现问题</a></li>
<li><a href="#_19">几个常见的动态分区分配</a></li>
<li><a href="#_20">内存碎片</a></li>
<li><a href="#_21">=&gt; 非连续内存分配机制</a></li>
</ul>
</li>
<li><a href="#io_4">采用分页技术的操作系统执行IO的全过程</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="java-io">Java IO 基础</h1>
<p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，<strong>流的本质是数据传输</strong>，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<p><small>参考： https://www.cnblogs.com/QQ846300233/p/6046388.html</small></p>
<ul>
<li>字节流 InputStream/OutStream</li>
</ul>
<p>字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p>
<ul>
<li>字符流 Reader/Writer</li>
</ul>
<h1 id="how-java-io-works-internally-at-lower-level">How Java I/O Works Internally at Lower Level?</h1>
<h2 id="_1">缓冲区</h2>
<p>计算机访问外部设备或文件，要比直接访问内存慢的多。如果我们每次调用<code>read()</code>方法或者<code>write()</code>方法访问外部的设备或文件，CPU就要花上最多的时间是在等外部设备响应，而不是数据处理。为此，我们开辟一个内存缓冲区的内存区域，程序每次调用<code>read()</code>方法或<code>write()</code>方法都是读写在这个缓冲区中。当这个缓冲区被装满后，系统才将这个缓冲区的内容一次集中写到外部设备或读取进来给CPU。使用缓冲区可以有效的提高CPU的使用率，能提高整个计算机系统的效率。在字符流操作中，所有的字符都是在内存中形成的，在字符流输出前都将保存在内存中的缓冲区内。</p>
<h2 id="_2">缓冲流</h2>
<p>在读写数据时，让数据在缓冲区能减少系统实际对原始数据来源的存取次数，因为一次能做多个数据单位的操作，相较而言，对于从文件读取数据或将数据写入文件，比起缓冲区的读写要慢多了。所以使用有缓冲区的流，一般都会比没有缓冲区的流效率更高，拥有缓冲区的流别称为缓冲流，包括BufferedInputStream、BufferedOutputStream类和BufferedReader、BufferedWriter类。缓冲流把数据从原始流成块读入或把数据积累到一个大数据块后再成批写出，通过减少通过资源的读写次数来加快程序的执行</p>
<h2 id="_3">用户空间,内核空间,磁盘</h2>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io/imgs/io_buffer.png" /></p>
<p>在磁盘空间和用户空间中加一个内核空间的缓存区的原因有两个：</p>
<ol>
<li>一个是用户空间的程序不能直接去磁盘空间中读取数据，必须由经由内核空间通过DMA来获取;</li>
<li>另一个原因是一般用户空间的内存分页与磁盘空间不会对齐，因此需要由内核空间在中间做一层处理。</li>
</ol>
<p>目前的操作系统，用户空间和内核空间的区分一般采用虚拟内存来实现，因此用户空间和内存空间都是在虚拟内存中。使用虚拟内存无非是因为其两大优势：一是它可以使多个虚拟内存地址指向同一个物理内存;二是虚拟内存的空间可以大于物理内存的空间。</p>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io/imgs/io_buffer_virtual.png" /></p>
<p><small>参考： https://blog.csdn.net/u012129558/article/details/82878994</small></p>
<ul>
<li>
<p>当用户空间所需要的数据在内核空间中已经存在，那么内核无需再次向磁盘控制硬件发起<code>系统调用</code>，直接<strong>对内核缓冲区进行复制</strong>，这些数据成为高速缓存，当然内核也可以预读取用户空间需要的数据。</p>
</li>
<li>
<p>用户空间通常是常规进程所在区域，即非特权区域，不能直接访问磁盘硬件设备；</p>
</li>
<li>
<p>使用虚拟内存<strong>省去了用户空间和内存空间的数据往来拷贝</strong>，但缓冲区的大小必须是磁盘数据块的倍数，用户空间和内核空间也必须使用相同的页对其方式。</p>
</li>
</ul>
<h2 id="io">文件IO</h2>
<p>文件系统是安排、解释磁盘数据的一种独特方式，文件系统定义了文件名、路径、文件、文件属性等一系列抽象概念。</p>
<p>当用户进程请求文件数据时，文件系统需要确定数据在磁盘什么位置，然后将相关磁盘分区读进内存。</p>
<h3 id="_4">内存映射文件(用户内存到文件系统页的映射)</h3>
<p>由一个文件到一块内存的映射；文件的数据就是这块区域内存中对应的数据，读写文件中的数据，直接对这块区域的地址操作，就可以，减少了内存复制的环节。</p>
<p>使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作，这意味着在对文件进行处理时将不必再为文件申请并分配缓存，所有的文件缓存操作均由系统直接管理，由于取消了将文件数据加载到内存、数据从内存到文件的回写以及释放内存块等步骤，使得内存映射文件在处理大数据量的文件时能起到相当重要的作用。</p>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io/imgs/mem_file.png" /></p>
<p>好处：</p>
<ul>
<li>
<p>用户进程把文件数据当作内存，所以无需发布<code>read()</code>或 <code>write()</code>系统调用。</p>
</li>
<li>
<p>当用户进程碰触到映射内存空间，页错误会自动产生，从而将文件数据从磁盘读进内存。如果用户修改了映射内存空间，相关页会自动标记为脏，随后刷新到磁盘，文件得到更新。</p>
</li>
<li>
<p>操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管<br />
理。</p>
</li>
<li>
<p>数据总是按页对齐的，无需执行缓冲区拷贝。</p>
</li>
<li>
<p>大型文件使用映射，无需耗费大量内存，即可进行数据拷贝。</p>
</li>
</ul>
<h1 id="io_1">IO模型</h1>
<h2 id="_5">阻塞与非阻塞</h2>
<p>函数或方法（用户线程调用内核IO操作）的实现方式：</p>
<ul>
<li>阻塞是指IO操作需要彻底完成后才返回到用户空间</li>
<li>非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</li>
</ul>
<h2 id="_6">同步与异步</h2>
<p>用户线程与内核的交互方式，</p>
<ul>
<li>
<p>同步指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；同步有阻塞，非阻塞</p>
</li>
<li>
<p>异步是指用户线程发起IO请求后仍然继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。异步一定是非阻塞的</p>
</li>
</ul>
<h2 id="io_2">常见网络IO模型</h2>
<h3 id="_7">同步阻塞</h3>
<p>用户线程的IO处理过程需要等待，中间不能做任何事情，对CPU利用率很低</p>
<h3 id="_8">同步非阻塞</h3>
<p>用户线程每次IO请求都能立刻返回，需要通过轮询去判断数据是否返回，会无谓地消耗大量的CPU</p>
<h3 id="io_3">IO复用</h3>
<ol>
<li>
<p>等待数据准备好（waiting for data to be ready）。对于一个套接口上的操作，这一步骤关系到数据从网络到达，并将其复制到内核的某个缓冲区。</p>
</li>
<li>
<p>将数据从内核缓冲区复制到进程缓冲区（copying the data from the kernel to the process）</p>
</li>
</ol>
<p><strong>IO多路复用</strong>是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。I</p>
<h4 id="select">select</h4>
<p>Select是通过将需要监听的文件描述符加入相应的文件描述符集合(readset、writeset，exceptset)，由内核负责监视相应的文件描述符是否就绪。</p>
<p>目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，但select有如下的一些局限</p>
<ul>
<li>select监控的文件描述符有上限</li>
<li>每次调用都需要手动的设置文件描述符集合，使用非常不便</li>
<li>每次调用都要把文件描述符从用户态拷贝到内核态，开销比较大</li>
<li>当就绪的文件描述符好后，需要循环遍历来进行判断，效率不好</li>
</ul>
<h4 id="poll">poll</h4>
<p>poll() 的机制与 select() 类似，与 select() 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理。</p>
<ul>
<li>
<p>优点</p>
</li>
<li>
<p>poll() 不要求开发者计算最大文件描述符加一的大小</p>
</li>
<li>poll() 在应付大数目的文件描述符的时候速度更快，相比于select</li>
<li>它没有最大连接数的限制，原因是它是基于链表来存储的</li>
<li>
<p>在调用函数时，只需要对参数进行一次设置就好了</p>
</li>
<li>
<p>缺点</p>
</li>
<li>
<p>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义</p>
</li>
<li>与select一样，poll返回后，需要轮询pollfd来获取就绪的描述符，这样会使性能下降</li>
<li>同时连接的大量客户端在一时刻可能只有很少的就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降</li>
</ul>
<h4 id="epoll">epoll</h4>
<p>https://github.com/doctording/linux_epoll</p>
<h3 id="iosignal-blocking-io">信号驱动IO（signal blocking I/O）</h3>
<p>当数据报准备好的时候，内核给应用程序发送一个信号，对SIGIO信号进行捕捉，并且调用应用程序的信号处理函数来获取数据报。</p>
<h2 id="_9">用户空间 &amp; 内核空间</h2>
<p>用户空间是常规进程所在区域。<code>JVM</code>就是常规进程，驻守于用户空间。用户空间是非特权区域:比如，在该区域执行的代码就不能直接访问硬件设备。内核空间是操作系统所在区域。内核代码有特别的权力:它能与设备控制器通讯，控制着用户区域 进程的运行状态，等等。最重要的是，所有<code>I/O</code>都直接或间接通过内核空间。</p>
<p>当进程请求<code>I/O</code>操作的时候，它执行一个系统调用(有时称为陷阱)将控制权移交给内核。 C/C++程序员所熟知的底层函数 open( )、read( )、write( )和 close( )要做的无非就是建立和执行适当的<code>系统调用</code>。当内核以这种方式被调用，它随即采取任何必要步骤，找到进程所需数据，并把数据 传送到用户空间内的指定缓冲区。内核试图对数据进行高速缓存或预读取，因此进程所需数据可能 已经在内核空间里了。如果是这样，该数据只需简单地拷贝出来即可。如果数据不在内核空间，则 进程被挂起，内核着手把数据读进内存。</p>
<h3 id="_10">为什么不直接 让磁盘控制器把数据送到用户空间的缓冲区呢?</h3>
<ul>
<li>硬件通常不能直接访问 用户空间；硬件设备通常不能直接使用虚拟内存地址</li>
<li>像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请 求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责 数据的分解、再组合工作，因此充当着中间人的角色</li>
</ul>
<h2 id="33">3.3 虚拟内存</h2>
<p>虚拟内存是计算机系统内存管理的一种技术。</p>
<p>它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。</p>
<p>所有程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用，来解决该问题</p>
<h3 id="_11">同时将多个进程保存在内存中以便允许多道程序设计？（最初的目标）</h3>
<h4 id="_12">一次性</h4>
<p>作业必须一次性全部装入内存后，方能开始运行。这会导致两种情况发生：<br />
当作业很大，不能全部被装入内存时，将使该作业无法运行；<br />
当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</p>
<h4 id="_13">驻留性</h4>
<p>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待I/O而被阻塞，可能处于长期等待状态。</p>
<p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p>
<h3 id="_14">局部性原理(虚拟内存技术实现的条件)</h3>
<h4 id="_15">时间局部性</h4>
<p>如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</p>
<h4 id="_16">空间局部性</h4>
<p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</p>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="_17">局部性原理=&gt;虚拟存储器</h3>
<p>基于局部性原理，在程序<strong>装入时</strong>，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序<strong>执行过程中</strong>，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</p>
<ul>
<li>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。</li>
<li>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</li>
<li>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</li>
</ul>
<h3 id="_18">虚拟内存技术的实现 和 面临的实现问题</h3>
<p>虚拟内存中，允许将一个作业分多次调入内存。操作系统如何分配内存？逻辑地址与物理地址的映射?</p>
<h3 id="_19">几个常见的动态分区分配</h3>
<ul>
<li>最先匹配(First-fit)</li>
</ul>
<p>优势：简单、易于产生更大空闲块、在高地址空间有大块的空闲分区<br />
劣势：外部碎片、分配大块时较慢</p>
<ul>
<li>最佳匹配(Best-fit)</li>
</ul>
<p>优势：当大部分分配时小尺寸时非常有效<br />
劣势：外部碎片、释放分区较慢、易产生很多没用的微小碎片（不怎么好）</p>
<ul>
<li>最差匹配(Worst-fit)</li>
</ul>
<p>优势：假如分配时中等尺寸效果最好、避免出现太多的小碎片<br />
劣势：重分配慢、外部碎片、易于破碎大的空闲块以致大分区无法被分配</p>
<h3 id="_20">内存碎片</h3>
<p>内存中无法被利用的存储空间称为碎片。</p>
<p>内部碎片：指分配给作业的存储空间中未被利用的部分，如固定分区中存在的碎片。</p>
<p>外部碎片：指系统中无法利用的小的空闲分区。如分区与分区之间存在的碎片。这些不连续的区间就是外部碎片。</p>
<h3 id="_21">=&gt; 非连续内存分配机制</h3>
<ul>
<li>请求<code>分页</code>存储管理</li>
<li>请求<code>分段</code>存储管理</li>
<li>请求<code>段页式</code>存储管理</li>
</ul>
<p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：</p>
<ul>
<li>一定容量的内存和外存。</li>
<li>页表机制（或段表机制），作为主要的数据结构。</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</li>
<li>地址变换机构，逻辑地址到物理地址的变换。</li>
</ul>
<h2 id="io_4">采用分页技术的操作系统执行IO的全过程</h2>
<ul>
<li>
<p>确定请求的数据分布在文件系统的哪些页(磁盘扇区组)。磁盘上的文件内容和元数 据可能跨越多个文件系统页，而且这些页可能也不连续。</p>
</li>
<li>
<p>在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。</p>
</li>
<li>
<p>在内存页与磁盘上的文件系统页之间建立映射。</p>
</li>
<li>
<p>为每一个内存页产生页错误</p>
</li>
<li>
<p>虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。</p>
</li>
<li>
<p>一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性<br />
信息。</p>
</li>
</ul>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-03-07 23:03:32</p>
      </span>
    </div>

    
    
  </body>
</html>