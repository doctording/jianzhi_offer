<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>对象的wait和notify方法 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_utils">java_utils</a>&nbsp;&#187;&nbsp;对象的wait和notify方法
    <span class="updated">Page Updated&nbsp;
      2019-03-09 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">对象的wait和notify方法</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#wait-nofiy">wait &amp; nofiy</a><ul>
<li><a href="#wait-1">wait 源码说明1</a></li>
<li><a href="#1">例子1</a></li>
<li><a href="#wait-sleep">wait 和 sleep 的区别</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="wait-nofiy">wait &amp; nofiy</h1>
<p>都是基类<code>Object</code>中的方法</p>
<ul>
<li><code>object's monitor</code></li>
<li><code>wait set</code></li>
<li>synchronized</li>
</ul>
<h2 id="wait-1">wait 源码说明1</h2>
<div class="hlcode"><pre> <span class="cm">/**</span>
<span class="cm">     * Causes the current thread to wait until either another thread invokes the</span>
<span class="cm">     * {@link java.lang.Object#notify()} method or the</span>
<span class="cm">     * {@link java.lang.Object#notifyAll()} method for this object, or a</span>
<span class="cm">     * specified amount of time has elapsed.</span>
<span class="cm">     * &lt;p&gt;</span>
<span class="cm">     * The current thread must own this object&#39;s monitor.</span>
<span class="cm">     * &lt;p&gt;</span>
<span class="cm">     * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to</span>
<span class="cm">     * place itself in the wait set for this object and then to relinquish</span>
<span class="cm">     * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt;</span>
<span class="cm">     * becomes disabled for thread scheduling purposes and lies dormant</span>
<span class="cm">     * until one of four things happens:</span>
<span class="cm">     * &lt;ul&gt;</span>
<span class="cm">     * &lt;li&gt;Some other thread invokes the {@code notify} method for this</span>
<span class="cm">     * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as</span>
<span class="cm">     * the thread to be awakened.</span>
<span class="cm">     * &lt;li&gt;Some other thread invokes the {@code notifyAll} method for this</span>
<span class="cm">     * object.</span>
<span class="cm">     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt() interrupts}</span>
<span class="cm">     * thread &lt;var&gt;T&lt;/var&gt;.</span>
<span class="cm">     * &lt;li&gt;The specified amount of real time has elapsed, more or less.  If</span>
<span class="cm">     * {@code timeout} is zero, however, then real time is not taken into</span>
<span class="cm">     * consideration and the thread simply waits until notified.</span>
<span class="cm">     * &lt;/ul&gt;</span>
<span class="cm">     * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this</span>
<span class="cm">     * object and re-enabled for thread scheduling. It then competes in the</span>
<span class="cm">     * usual manner with other threads for the right to synchronize on the</span>
<span class="cm">     * object; once it has gained control of the object, all its</span>
<span class="cm">     * synchronization claims on the object are restored to the status quo</span>
<span class="cm">     * ante - that is, to the situation as of the time that the {@code wait}</span>
<span class="cm">     * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the</span>
<span class="cm">     * invocation of the {@code wait} method. Thus, on return from the</span>
<span class="cm">     * {@code wait} method, the synchronization state of the object and of</span>
<span class="cm">     * thread {@code T} is exactly as it was when the {@code wait} method</span>
<span class="cm">     * was invoked.</span>
<span class="cm">     * &lt;p&gt;</span>
<span class="cm">     * A thread can also wake up without being notified, interrupted, or</span>
<span class="cm">     * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/i&gt;.  While this will rarely</span>
<span class="cm">     * occur in practice, applications must guard against it by testing for</span>
<span class="cm">     * the condition that should have caused the thread to be awakened, and</span>
<span class="cm">     * continuing to wait if the condition is not satisfied.  In other words,</span>
<span class="cm">     * waits should always occur in loops, like this one:</span>
<span class="cm">     * &lt;pre&gt;</span>
<span class="cm">     *     synchronized (obj) {</span>
<span class="cm">     *         while (&amp;lt;condition does not hold&amp;gt;)</span>
<span class="cm">     *             obj.wait(timeout);</span>
<span class="cm">     *         ... // Perform action appropriate to condition</span>
<span class="cm">     *     }</span>
<span class="cm">     * &lt;/pre&gt;</span>
<span class="cm">     * (For more information on this topic, see Section 3.2.3 in Doug Lea&#39;s</span>
<span class="cm">     * &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley,</span>
<span class="cm">     * 2000), or Item 50 in Joshua Bloch&#39;s &quot;Effective Java Programming</span>
<span class="cm">     * Language Guide&quot; (Addison-Wesley, 2001).</span>
<span class="cm">     *</span>
<span class="cm">     * &lt;p&gt;If the current thread is {@linkplain java.lang.Thread#interrupt()</span>
<span class="cm">     * interrupted} by any thread before or while it is waiting, then an</span>
<span class="cm">     * {@code InterruptedException} is thrown.  This exception is not</span>
<span class="cm">     * thrown until the lock status of this object has been restored as</span>
<span class="cm">     * described above.</span>
<span class="cm">     *</span>
<span class="cm">     * &lt;p&gt;</span>
<span class="cm">     * Note that the {@code wait} method, as it places the current thread</span>
<span class="cm">     * into the wait set for this object, unlocks only this object; any</span>
<span class="cm">     * other objects on which the current thread may be synchronized remain</span>
<span class="cm">     * locked while the thread waits.</span>
<span class="cm">     * &lt;p&gt;</span>
<span class="cm">     * This method should only be called by a thread that is the owner</span>
<span class="cm">     * of this object&#39;s monitor. See the {@code notify} method for a</span>
<span class="cm">     * description of the ways in which a thread can become the owner of</span>
<span class="cm">     * a monitor.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      timeout   the maximum time to wait in milliseconds.</span>
<span class="cm">     * @throws  IllegalArgumentException      if the value of timeout is</span>
<span class="cm">     *               negative.</span>
<span class="cm">     * @throws  IllegalMonitorStateException  if the current thread is not</span>
<span class="cm">     *               the owner of the object&#39;s monitor.</span>
<span class="cm">     * @throws  InterruptedException if any thread interrupted the</span>
<span class="cm">     *             current thread before or while the current thread</span>
<span class="cm">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span>
<span class="cm">     *             status&lt;/i&gt; of the current thread is cleared when</span>
<span class="cm">     *             this exception is thrown.</span>
<span class="cm">     * @see        java.lang.Object#notify()</span>
<span class="cm">     * @see        java.lang.Object#notifyAll()</span>
<span class="cm">     */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>
</pre></div>


<h2 id="1">例子1</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>
        <span class="n">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;A start&quot;</span><span class="o">);</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;A notify&quot;</span><span class="o">);</span>
                    <span class="c1">// 唤醒对应的线程</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B start&quot;</span><span class="o">);</span>
            <span class="kd">synchronized</span><span class="o">(</span><span class="n">threadA</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 使得当前执行的线程B等待</span>
                    <span class="c1">// 即：当前线程B 进入到 threadA对象的等待集合中 并等待唤醒。</span>
                    <span class="c1">// B 释放其cpu给其它线程，自己让出资源进入等待池(A的等待集合中)等待</span>
                    <span class="n">threadA</span><span class="o">.</span><span class="na">wait</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B running&quot;</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B Exception&quot;</span><span class="o">);</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B end&quot;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="n">threadA</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;main end&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* ouput</span>
<span class="cm">A start</span>
<span class="cm">B start</span>
<span class="cm">A notify</span>
<span class="cm">B running</span>
<span class="cm">B end</span>
<span class="cm">main end</span>
<span class="cm">*/</span>
</pre></div>


<p><code>synchronized(threadA)</code>锁定threadA（获得threadA的monitor）</p>
<p><code>wait</code>操作会释放对象的monitor，如果原先没有锁定，则会抛出<code>java.lang.IllegalMonitorStateException</code></p>
<div class="hlcode"><pre><span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B start&quot;</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 使得当前执行的线程B等待</span>
                <span class="n">threadA</span><span class="o">.</span><span class="na">wait</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B running&quot;</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B Exception&quot;</span><span class="o">);</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B end&quot;</span><span class="o">);</span>
        <span class="o">});</span>
</pre></div>


<ul>
<li>output</li>
</ul>
<div class="hlcode"><pre><span class="n">A</span> <span class="n">start</span>
<span class="n">B</span> <span class="n">start</span>
<span class="n">B</span> <span class="n">Exception</span>
<span class="n">B</span> <span class="n">end</span>
<span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalMonitorStateException</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">.</span><span class="na">wait</span><span class="o">(</span><span class="n">Native</span> <span class="n">Method</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">parallel</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">lambda</span><span class="n">$main$0</span><span class="o">(</span><span class="n">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">31</span><span class="o">)</span>
    <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Thread</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">748</span><span class="o">)</span>
<span class="n">A</span> <span class="n">notify</span>
<span class="n">main</span> <span class="n">end</span>
</pre></div>


<h2 id="wait-sleep"><code>wait</code> 和 <code>sleep</code> 的区别</h2>
<ol>
<li>
<p>wait()方法属于Object类,sleep()属于Thread类；</p>
</li>
<li>
<p>wait()方法释放cpu给其它线程，自己让出资源进入等待池等待；sleep继续占用cpu，不让出资源；</p>
</li>
<li>
<p>sleep()必须指定时间，wait()可以指定时间也可以不指定；sleep()时间到，线程处于临时阻塞或运行状态；</p>
</li>
<li>
<p>wait()方法会释放持有的锁，不然其它线程不能进入同步方法或同步块，从而不能调用notify(),notifyAll()方法来唤醒线程，产生死锁，所以释放锁，可以执行其他线程，也可以唤醒自己，只是设置停止自己的时间时不确定的；sleep方法不会释放持有的锁，设置sleep的时间是确定的会按时执行的；</p>
</li>
<li>
<p>wait()方法只能在同步方法或同步代码块中调用，否则会报<code>illegalMonitorStateException</code>异常，如果没有设定时间，使用notify()来唤醒；而sleep()能在任何地方调用；</p>
</li>
</ol>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-04-09 23:32:41</p>
      </span>
    </div>

    
    
  </body>
</html>