<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>剑指Offer解题思路 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#methods_of_solve">methods_of_solve</a>&nbsp;&#187;&nbsp;剑指Offer解题思路
    <span class="updated">Page Updated&nbsp;
      2018-05-30 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">剑指Offer解题思路</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1">1 二维数组中的查找</a></li>
<li><a href="#2">2 替换空格</a></li>
<li><a href="#3">3 从尾到头打印链表</a></li>
<li><a href="#4">4 重建二叉树</a></li>
<li><a href="#5">5 用两个栈实现队列</a></li>
<li><a href="#6">6 旋转数组的最小数字</a></li>
<li><a href="#7">7 斐波那契数列</a></li>
<li><a href="#8">8 跳台阶</a></li>
<li><a href="#9">9 变态跳台阶</a></li>
<li><a href="#10">10 矩形覆盖</a></li>
<li><a href="#11-1">11 二进制中1的个数</a></li>
<li><a href="#12">12 数值的整数次方</a></li>
<li><a href="#13">13 调整数组顺序使奇数位于偶数前面 （？？）</a></li>
<li><a href="#14-k">14 链表中倒数第k个结点</a></li>
<li><a href="#15">15 反转链表</a></li>
<li><a href="#16">16 合并两个排序的链表</a></li>
<li><a href="#17">17 树的子结构 ??</a></li>
<li><a href="#18">18 二叉树的镜像</a></li>
<li><a href="#19">19 顺时针打印矩阵</a></li>
<li><a href="#20-min">20 包含min函数的栈</a></li>
<li><a href="#21">21 栈的压入、弹出序列</a></li>
<li><a href="#22">22 从上往下打印二叉树</a></li>
<li><a href="#23">23 二叉搜索树的后序遍历序列</a></li>
<li><a href="#24">24 二叉树中和为某一值的路径</a></li>
<li><a href="#25">25 复杂链表的复制 ??</a></li>
<li><a href="#26">26 二叉搜索树与双向链表</a></li>
<li><a href="#27">27 字符串的排列</a></li>
<li><a href="#28">28 数组中出现次数超过一半的数字</a></li>
<li><a href="#29-k">29 最小的K个数</a></li>
<li><a href="#30">30 连续子数组的最大和</a></li>
<li><a href="#31-11n1">31 整数中1出现的次数（从1到n整数中1出现的次数） ？？</a></li>
<li><a href="#32">32 把数组排成最小的数</a></li>
<li><a href="#33">33 丑数</a></li>
<li><a href="#34">34 第一个只出现一次的字符</a></li>
<li><a href="#35">35 数组中的逆序对 ？？</a></li>
<li><a href="#36">36 两个链表的第一个公共结点 ？</a></li>
<li><a href="#37">37 数字在排序数组中出现的次数</a></li>
<li><a href="#38">38 二叉树的深度</a></li>
<li><a href="#39">39 输入一棵二叉树，判断该二叉树是否是平衡二叉树</a></li>
<li><a href="#40">40 数组中只出现一次的数字</a></li>
<li><a href="#41-s">41 和为S的连续正数序列</a></li>
<li><a href="#42-s">42 和为S的两个数字</a></li>
<li><a href="#43">43 左旋转字符串</a></li>
<li><a href="#44">44 翻转单词顺序列</a></li>
<li><a href="#45">45 扑克牌顺子</a></li>
<li><a href="#46">46 孩子们的游戏(圆圈中最后剩下的数)</a></li>
<li><a href="#47-123n">47 求1+2+3+...+n</a></li>
<li><a href="#48">48 不用加减乘除做加法</a></li>
<li><a href="#49">49 把字符串转换成整数</a></li>
<li><a href="#50">50 数组中重复的数字 ？？</a></li>
<li><a href="#51">51 构建乘积数组</a></li>
<li><a href="#52">52 正则表达式匹配 ？？</a></li>
<li><a href="#53">53 表示数值的字符串  ??</a></li>
<li><a href="#54">54 字符流中第一个不重复的字符</a></li>
<li><a href="#55">55 链表中环的入口结点</a></li>
<li><a href="#56">56 删除链表中重复的结点</a></li>
<li><a href="#57">57 二叉树的下一个结点， 中序遍历顺序的下一个结点并且返回 ？？</a></li>
<li><a href="#58">58 对称的二叉树</a></li>
<li><a href="#59">59 按之字形顺序打印二叉树</a></li>
<li><a href="#60">60 把二叉树打印成多行</a></li>
<li><a href="#61">61 序列化二叉树</a></li>
<li><a href="#62-k">62 二叉搜索树的第k个结点</a></li>
<li><a href="#63">63 数据流中的中位数</a></li>
<li><a href="#64">64 滑动窗口的最大值</a></li>
<li><a href="#65">65 矩阵中的路径</a></li>
<li><a href="#66">66 机器人的运动范围</a></li>
</ul>
</div>
<h1 id="1">1 二维数组中的查找</h1>
<ul>
<li>有序查找 二分</li>
</ul>
<h1 id="2">2 替换空格</h1>
<ul>
<li>先统计增大的空间，然后从后往前替换</li>
</ul>
<h1 id="3">3 从尾到头打印链表</h1>
<ul>
<li>
<p>头插法将链表反转一下，然后遍历（这种方式会改变链表的结构）</p>
</li>
<li>
<p>当链表只读时，采用递归的方法（栈）来操作，就可以实现链表数据的反转了</p>
</li>
</ul>
<h1 id="4">4 重建二叉树</h1>
<ul>
<li>这类题目都采用递归，二叉树基本题</li>
</ul>
<h1 id="5">5 用两个栈实现队列</h1>
<ul>
<li>保持一个stack为空，通过两个栈转储，实现数据进出是队列形式的</li>
</ul>
<h1 id="6">6 旋转数组的最小数字</h1>
<ul>
<li>
<p>头尾往中间逼近的方法,直接遍历一遍，O(n)的做法，显然太low</p>
</li>
<li>
<p>二分查找的方法，不过有特殊情况，比如 [1 0 1 1 1] ，[1 1 1 0 1] 这种，需要单独顺序遍历</p>
</li>
</ul>
<h1 id="7">7 斐波那契数列</h1>
<ul>
<li>
<p>最直接的递归/动归， O(2^n), n的指数次方增长</p>
</li>
<li>
<p>利用变量,非递归，时间复杂度O(n)</p>
</li>
<li>
<p>快速幂的做法  f(n) = f(n - 1) + f(n - 2), 二阶的快速幂，时间复杂度O(logn),需要推算一下矩阵公式</p>
</li>
</ul>
<h1 id="8">8 跳台阶</h1>
<ul>
<li>同 斐波那契数列</li>
</ul>
<h1 id="9">9 变态跳台阶</h1>
<p>数学公式推导</p>
<h1 id="10">10 矩形覆盖</h1>
<ul>
<li>同 斐波那契数列</li>
</ul>
<h1 id="11-1">11 二进制中1的个数</h1>
<ul>
<li>经典问题，采用位运算</li>
</ul>
<h1 id="12">12 数值的整数次方</h1>
<ul>
<li>
<p>快速幂方法</p>
</li>
<li>
<p>边界, 符号， double/float判零问题</p>
</li>
<li>
<p>位运算比除法, 取模等效率高</p>
</li>
</ul>
<h1 id="13">13 调整数组顺序使奇数位于偶数前面 （？？）</h1>
<ul>
<li>
<p>注意无序和有序的区别</p>
</li>
<li>
<p>无序</p>
<ol>
<li>快排思路，维持头，尾两个指针，不断的交换到相遇,时间O(n), 空间O(1)</li>
</ol>
</li>
<li>
<p>要求保持数据相对位置不变</p>
<ol>
<li>直接插入排序， 时间复杂度O(n^2), 空间复杂度O(1)</li>
<li>归并排序， 时间复杂度O(nlogn), 空间复杂度O(1)，归并排序是稳定的排序</li>
<li>利用复杂空间，空间复杂度O(n), 时间复杂度O(n)（直接遍历一遍）</li>
</ol>
</li>
</ul>
<h1 id="14-k">14 链表中倒数第k个结点</h1>
<ul>
<li>两个指针，保持距离k,那么一个链表尾部，一个就是倒数k</li>
</ul>
<h1 id="15">15 反转链表</h1>
<ul>
<li>直接遍历，头插法</li>
</ul>
<h1 id="16">16 合并两个排序的链表</h1>
<ul>
<li>
<p>每个链表一个游标，边比较边连接，最后多的直接连接</p>
</li>
<li>
<p>递归思路，因为链表总是有序的，对两个链表头节点处理后，剩下的操作更前面的一样的</p>
</li>
</ul>
<h1 id="17">17 树的子结构 ??</h1>
<ul>
<li>注意 子结构 和 子树的区别</li>
</ul>
<p>子树的意思是包含了一个结点，就得包含这个结点下的所有节点，一棵大小为n的二叉树有n个子树，就是分别以每个结点为根的子树。</p>
<p>子结构的意思是包含了一个结点，可以只取左子树或者右子树，或者都不取。</p>
<ul>
<li>子树问题 可以采用 序列化方法，而子结构不能采用序列化方法</li>
</ul>
<p>此题 递归求解，要么根，要么与左子树匹配，要么与右子树匹配,递归需要注意</p>
<h1 id="18">18 二叉树的镜像</h1>
<p>递归，注意顺序</p>
<h1 id="19">19 顺时针打印矩阵</h1>
<ul>
<li>一圈一圈的打印，可以封装成一个方法</li>
</ul>
<h1 id="20-min">20 包含min函数的栈</h1>
<ul>
<li>维持两个栈，一个普通栈，一个存放min的栈，两个栈对应</li>
</ul>
<h1 id="21">21 栈的压入、弹出序列</h1>
<ul>
<li>直接利用STL stack等结构, 去模拟栈的压入、弹出过程</li>
</ul>
<h1 id="22">22 从上往下打印二叉树</h1>
<p>直接层次遍历</p>
<h1 id="23">23 二叉搜索树的后序遍历序列</h1>
<ul>
<li>判断后续是否合法</li>
<li>问清楚有没有重复数字，搜索树是怎样的排序</li>
<li>根据后序：左 右 根的顺序，递归判断是否满足二叉树的大小关系</li>
</ul>
<h1 id="24">24 二叉树中和为某一值的路径</h1>
<p>DFS 或 BFS</p>
<h1 id="25">25 复杂链表的复制 ??</h1>
<h1 id="26">26 二叉搜索树与双向链表</h1>
<ul>
<li>二叉树的非递归遍历 ？</li>
</ul>
<h1 id="27">27 字符串的排列</h1>
<ul>
<li>递归法，需要判断重复的串</li>
<li>可排序，然后判断，也可以采用set等数据结构</li>
</ul>
<h1 id="28">28 数组中出现次数超过一半的数字</h1>
<ul>
<li>cur, count，（每次取两个不一样的数删除)　最后验证</li>
</ul>
<h1 id="29-k">29 最小的K个数</h1>
<ul>
<li>
<p>快排思路</p>
</li>
<li>
<p>堆排序思路 O(nlogk)时间复杂度，适合处理海量数据,采用红黑树（stl中的set,multiset都是基于红黑树的）</p>
</li>
</ul>
<h1 id="30">30 连续子数组的最大和</h1>
<p>*动归</p>
<h1 id="31-11n1">31 整数中1出现的次数（从1到n整数中1出现的次数） ？？</h1>
<ul>
<li>
<p>遍历1到n,对每个数采用mod 10 取得1的个数，时间复杂度达到O(nlogn)</p>
</li>
<li>
<p>找规律的方法，时间复杂度达到O(logn), 参考如下的讲解<br />
http://blog.csdn.net/yi_afly/article/details/52012593</p>
</li>
</ul>
<h1 id="32">32 把数组排成最小的数</h1>
<ul>
<li>两两组合排序，注意0</li>
</ul>
<h1 id="33">33 丑数</h1>
<h1 id="34">34 第一个只出现一次的字符</h1>
<ul>
<li>hash</li>
</ul>
<h1 id="35">35 数组中的逆序对 ？？</h1>
<ul>
<li>归并排序思路</li>
</ul>
<h1 id="36">36 两个链表的第一个公共结点 ？</h1>
<ul>
<li>单链表是否存在环<br />
 走一步，走两步,进一步可以找到第一个公共节点</li>
</ul>
<p>*直接利用map</p>
<ul>
<li>将两个链表先处理成一样长的，然后再判断</li>
</ul>
<h1 id="37">37 数字在排序数组中出现的次数</h1>
<ul>
<li>二分查找，然后左右扩散开统计</li>
</ul>
<h1 id="38">38 二叉树的深度</h1>
<ul>
<li>递归</li>
</ul>
<h1 id="39">39 输入一棵二叉树，判断该二叉树是否是平衡二叉树</h1>
<ul>
<li>
<p>1 每个节点都采用求深度的方法，这样遍历求解，重复计算量太大</p>
</li>
<li>
<p>2 后序遍历，递归判断每个节点是否平衡，因为先访问了左右子树，后访问根，所以需要用变量保存每个节点的深度</p>
</li>
</ul>
<h1 id="40">40 数组中只出现一次的数字</h1>
<ul>
<li>利用数的性质，异或运算</li>
</ul>
<h1 id="41-s">41 和为S的连续正数序列</h1>
<ul>
<li>数学公式</li>
</ul>
<h1 id="42-s">42 和为S的两个数字</h1>
<ul>
<li>排序 + 二分查找</li>
</ul>
<h1 id="43">43 左旋转字符串</h1>
<ul>
<li>
<p>三步翻转</p>
</li>
<li>
<p>改进三步翻转，用块交换</p>
</li>
</ul>
<h1 id="44">44 翻转单词顺序列</h1>
<ul>
<li>同 43 左旋转字符串 </li>
</ul>
<h1 id="45">45 扑克牌顺子</h1>
<ul>
<li>统计个数为5，大小王个数</li>
<li>排序，逐一判断，减去大小王数目</li>
</ul>
<h1 id="46">46 孩子们的游戏(圆圈中最后剩下的数)</h1>
<ul>
<li>约瑟夫环</li>
</ul>
<h1 id="47-123n">47 求1+2+3+...+n</h1>
<h1 id="48">48 不用加减乘除做加法</h1>
<ul>
<li>位运算模拟</li>
</ul>
<h1 id="49">49 把字符串转换成整数</h1>
<ul>
<li>注意最大负整数，最大正整数等特殊情况</li>
</ul>
<h1 id="50">50 数组中重复的数字 ？？</h1>
<h1 id="51">51 构建乘积数组</h1>
<ul>
<li>构建左部分乘积 和 右部分乘积序列</li>
<li></li>
</ul>
<h1 id="52">52 正则表达式匹配 ？？</h1>
<ul>
<li>递归 ？，.</li>
</ul>
<h1 id="53">53 表示数值的字符串  ??</h1>
<h1 id="54">54 字符流中第一个不重复的字符</h1>
<h1 id="55">55 链表中环的入口结点</h1>
<ul>
<li>链表环的判断</li>
</ul>
<h1 id="56">56 删除链表中重复的结点</h1>
<ul>
<li>链表删除节点模拟, 注意各种特殊情况</li>
</ul>
<h1 id="57">57 二叉树的下一个结点， 中序遍历顺序的下一个结点并且返回 ？？</h1>
<h1 id="58">58 对称的二叉树</h1>
<ul>
<li>
<p>对称二叉树概念：将一棵二叉树沿着根节点对折，如果两棵子树完全重合（对称节点要么都为null，要么数据域完全相等），那么该二叉树是一个对称二叉树。</p>
</li>
<li>
<p>1 递归求解 相当于在判断root-&gt;left, root-&gt;right 两棵树 是否对折相等</p>
</li>
<li>
<p>2 非递归，用两个队列，维持root-&gt;left, root-&gt;right,节点入队列顺序不一样，判断完全</p>
</li>
</ul>
<h1 id="59">59 按之字形顺序打印二叉树</h1>
<ul>
<li>按照层次遍历，加上标记</li>
</ul>
<h1 id="60">60 把二叉树打印成多行</h1>
<h1 id="61">61 序列化二叉树</h1>
<p>DFS 、BFS，要能反序列化</p>
<h1 id="62-k">62 二叉搜索树的第k个结点</h1>
<ul>
<li>非递归遍历 查找</li>
</ul>
<h1 id="63">63 数据流中的中位数</h1>
<h1 id="64">64 滑动窗口的最大值</h1>
<ul>
<li>利用 stack</li>
</ul>
<h1 id="65">65 矩阵中的路径</h1>
<ul>
<li>DFS</li>
</ul>
<h1 id="66">66 机器人的运动范围</h1>
<ul>
<li>DFS</li>
</ul>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2018 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2018-09-02 22:13:53</p>
      </span>
    </div>

    
    
  </body>
</html>