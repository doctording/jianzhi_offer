<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>数据库/表/查询 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#db_cache">db_cache</a>&nbsp;&#187;&nbsp;数据库/表/查询
    <span class="updated">Page Updated&nbsp;
      2020-03-08 18:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">数据库/表/查询</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#mysql">MySQL</a><ul>
<li><a href="#mysql_1">mysql的数据库引擎有哪些？</a></li>
<li><a href="#_1">数据库范式</a><ul>
<li><a href="#_2">第一范式</a></li>
<li><a href="#_3">第二范式</a></li>
<li><a href="#_4">第三范式</a></li>
<li><a href="#bcnf">BCNF范式</a></li>
</ul>
</li>
<li><a href="#join">数据表join操作</a><ul>
<li><a href="#hash-joinmerge-joinnested-loop">多表连接的三种方式详解 hash join、merge join、nested loop</a><ul>
<li><a href="#nested-loop">nested loop（嵌套循环）</a></li>
<li><a href="#hash-join">Hash Join</a></li>
<li><a href="#merge-join">merge join</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="mysql">MySQL</h1>
<p><a href="https://dev.mysql.com/doc/">官方文档</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/">mysql 5.6</a></p>
<p><a href="https://blog.csdn.net/qq_26437925/category_5779305.html">我个博客专题</a></p>
<p>本文主要补充一些常考笔试，面试题</p>
<h2 id="mysql_1">mysql的数据库引擎有哪些？</h2>
<ol>
<li>InnoDB</li>
<li>Myisam</li>
<li>
<p>Memory</p>
</li>
<li>
<p>InnoDB,Myisam的默认索引是B+tree，Memory的默认索引是hash</p>
</li>
<li>InnoDB支持<strong>事务</strong>，支持<strong>外键</strong>，支持<strong>行锁</strong>，写入数据时操作快，MySQL5.6版本以上才支持<strong>全文索引</strong></li>
<li>*Myisam不支持事务。不支持外键，支持表锁，支持全文索引，读取数据快</li>
<li>Memory所有的数据都保留在内存中,不需要进行磁盘的IO所以读取的速度很快, 但是一旦关机,表的结构会保留但是数据就会丢失,表支持Hash索引，因此查找速度很快</li>
</ol>
<h2 id="_1">数据库范式</h2>
<h3 id="_2">第一范式</h3>
<p>每个属性都不可再分</p>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_jvm/imgs/1nf.png" /></p>
<h3 id="_3">第二范式</h3>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_jvm/imgs/bug.png" /></p>
<ol>
<li>
<p>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大</p>
</li>
<li>
<p>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——插入异常</p>
<ul>
<li>
<p>注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录</p>
</li>
<li>
<p>码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。</p>
</li>
</ul>
</li>
<li>
<p>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常</p>
</li>
<li>
<p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常</p>
</li>
</ol>
<p>“若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作<code>X → Y</code>”</p>
<p><strong>第二范式：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</strong></p>
<hr />
<ul>
<li>选课（学号，课名，分数）</li>
<li>学生（学号，姓名，系名，系主任）</li>
</ul>
<p>对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。</p>
<p>对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。</p>
<h3 id="_4">第三范式</h3>
<p><strong>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</strong></p>
<ul>
<li>学生（学号，姓名，系名，系主任）</li>
</ul>
<p>对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 <code>学号 → 系名</code>，同时 <code>系名 → 系主任</code>，所以存在非主属性<code>系主任</code>对于码<code>学号</code>的<strong>传递函数</strong>依赖，所以学生表的设计，不符合3NF的要求。</p>
<hr />
<ul>
<li>选课（学号，课名，分数）</li>
<li>学生（学号，姓名，系名）</li>
<li>系（系名，系主任）</li>
</ul>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_jvm/imgs/3nf.png" /></p>
<h3 id="bcnf">BCNF范式</h3>
<p>巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因</p>
<h2 id="join">数据表join操作</h2>
<ul>
<li>
<p>INNER JOIN: 内连接是最常见的一种连接，只连接匹配的行</p>
</li>
<li>
<p>LEFT JOIN: 返回左表的全部行和右表满足ON条件的行，如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替</p>
</li>
<li>
<p>RIGHT JOIN: 返回右表的全部行和左表满足ON条件的行，如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替</p>
</li>
<li>
<p>FULL OUTER JOIN: 会从左表 和右表 那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替</p>
</li>
<li>
<p>CROSS JOIN: 把表A和表B的数据进行一个N*M的组合，即笛卡尔积</p>
</li>
</ul>
<h3 id="hash-joinmerge-joinnested-loop">多表连接的三种方式详解 hash join、merge join、nested loop</h3>
<h4 id="nested-loop">nested loop（嵌套循环）</h4>
<p><strong>驱动表</strong>(也叫外表)和被驱动表(也叫<strong>非驱动表</strong>，还可以叫匹配表，亦可叫内表)，简单来说，驱动表就是主表，left join 中的左表就是驱动表，right join 中的右表是驱动表。一个是驱动表，那另一个就只能是非驱动表了</p>
<p>在 join 的过程中，其实就是从驱动表里面依次(注意理解这里面的依次)取出每一个值，然后去非驱动表里面进行匹配，那具体是怎么匹配的呢？这就是我们接下来讲的这三种连接方式：</p>
<ol>
<li>
<p>(Simple Nested-Loop Join )暴力匹配的方式；如果 table A 有10行，table B 有10行，总共需要执行10 x 10 = 100次查询</p>
</li>
<li>
<p>(Index Nested-Loop Join)这个 Index 是要求非驱动表上要有索引，有了索引以后可以减少匹配次数，匹配次数减少了就可以提高查询的效率了,eg:左边就是普通列的存储方式，右边是树结构索引, 能减少查询次数</p>
</li>
<li>
<p>(Block Nested-Loop Join)</p>
</li>
</ol>
<p>理想情况下，用索引匹配是最高效的一种方式，但是在现实工作中，并不是所有的列都是索引列，这个时候就需要用到 Block Nested-Loop Join 方法了，这种方法与第一种方法比较类似，唯一的区别就是:会把驱动表中 left join 涉及到的所有列(<strong>不止是用来on的列，还有select部分的列</strong>)先取出来放到一个<strong>缓存区域</strong>，然后再去和非驱动表进行匹配，这种方法和第一种方法相比所需要的匹配次数是一样的，差别就在于驱动表的列数不同，也就是数据量的多少不同。所以虽然匹配次数没有减少，但是总体的查询性能还是有提升的。</p>
<hr />
<p>适用于小表与小表的连接</p>
<h4 id="hash-join">Hash Join</h4>
<p>hash join仅仅在join的字段上<code>没有索引</code>时才起作用，在此之前，我们不建议在没有索引的字段上做join操作，因为通常中这种操作会执行得很慢，但是有了hash join，它<code>能够创建一个内存中的hash表</code>，代替之前的nested loop，使得没有索引的<code>等值join</code>性能提升很多。</p>
<ol>
<li>
<p>配置hash join功能是否开启：</p>
<ul>
<li>optimizer_switch 中的 hash_join=on/off，默认为on</li>
<li>sql语句中指定HASH_JOIN或者NO_HASH_JOIN<br />
限制：</li>
</ul>
</li>
<li>
<p>hash join只能在没有索引的字段上有效</p>
<ul>
<li>hash join只在等值join条件中有效</li>
<li>hash join不能用于left join和right join</li>
</ul>
</li>
</ol>
<hr />
<p>适用于小表与大表的连接</p>
<h4 id="merge-join">merge join</h4>
<p>merge join第一个步骤是确保两个关联表都是按照关联的字段进行排序。如果关联字段有可用的索引，并且排序一致，则可以直接进行merge join操作；</p>
<p>两个表都按照关联字段排序好之后，merge join操作从每个表取一条记录开始匹配，如果符合关联条件，则放入结果集中；否则，将关联字段值较小的记录抛弃，从这条记录对应的表中取下一条记录继续进行匹配，直到整个循环结束。</p>
<div class="hlcode"><pre> <span class="n">function</span> <span class="nf">sortMerge</span><span class="o">(</span><span class="n">relation</span> <span class="n">left</span><span class="o">,</span> <span class="n">relation</span> <span class="n">right</span><span class="o">,</span> <span class="n">attribute</span> <span class="n">a</span><span class="o">)</span>
     <span class="n">var</span> <span class="n">relation</span> <span class="n">output</span>
     <span class="n">var</span> <span class="n">list</span> <span class="n">left_sorted</span> <span class="o">:=</span> <span class="n">sort</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="c1">// Relation left sorted on attribute a</span>
     <span class="n">var</span> <span class="n">list</span> <span class="n">right_sorted</span> <span class="o">:=</span> <span class="n">sort</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
     <span class="n">var</span> <span class="n">attribute</span> <span class="n">left_key</span><span class="o">,</span> <span class="n">right_key</span>
     <span class="n">var</span> <span class="n">set</span> <span class="n">left_subset</span><span class="o">,</span> <span class="n">right_subset</span> <span class="c1">// These sets discarded except where join predicate is satisfied</span>
     <span class="n">advance</span><span class="o">(</span><span class="n">left_subset</span><span class="o">,</span> <span class="n">left_sorted</span><span class="o">,</span> <span class="n">left_key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
     <span class="n">advance</span><span class="o">(</span><span class="n">right_subset</span><span class="o">,</span> <span class="n">right_sorted</span><span class="o">,</span> <span class="n">right_key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
     <span class="k">while</span> <span class="n">not</span> <span class="nf">empty</span><span class="o">(</span><span class="n">left_subset</span><span class="o">)</span> <span class="n">and</span> <span class="n">not</span> <span class="n">empty</span><span class="o">(</span><span class="n">right_subset</span><span class="o">)</span>
         <span class="k">if</span> <span class="n">left_key</span> <span class="o">=</span> <span class="n">right_key</span> <span class="c1">// Join predicate satisfied</span>
             <span class="n">add</span> <span class="n">cartesian</span> <span class="n">product</span> <span class="n">of</span> <span class="n">left_subset</span> <span class="n">and</span> <span class="n">right_subset</span> <span class="n">to</span> <span class="n">output</span>
             <span class="nf">advance</span><span class="o">(</span><span class="n">left_subset</span><span class="o">,</span> <span class="n">left_sorted</span><span class="o">,</span> <span class="n">left_key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
             <span class="n">advance</span><span class="o">(</span><span class="n">right_subset</span><span class="o">,</span> <span class="n">right_sorted</span><span class="o">,</span> <span class="n">right_key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
         <span class="k">else</span> <span class="k">if</span> <span class="n">left_key</span> <span class="o">&lt;</span> <span class="n">right_key</span>
            <span class="n">advance</span><span class="o">(</span><span class="n">left_subset</span><span class="o">,</span> <span class="n">left_sorted</span><span class="o">,</span> <span class="n">left_key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
         <span class="k">else</span> <span class="c1">// left_key &gt; right_key</span>
            <span class="n">advance</span><span class="o">(</span><span class="n">right_subset</span><span class="o">,</span> <span class="n">right_sorted</span><span class="o">,</span> <span class="n">right_key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
     <span class="k">return</span> <span class="n">output</span>

 <span class="c1">// Remove tuples from sorted to subset until the sorted[1].a value changes</span>
 <span class="n">function</span> <span class="nf">advance</span><span class="o">(</span><span class="n">subset</span> <span class="n">out</span><span class="o">,</span> <span class="n">sorted</span> <span class="n">inout</span><span class="o">,</span> <span class="n">key</span> <span class="n">out</span><span class="o">,</span> <span class="n">a</span> <span class="n">in</span><span class="o">)</span>
     <span class="n">key</span> <span class="o">:=</span> <span class="n">sorted</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">a</span>
     <span class="n">subset</span> <span class="o">:=</span> <span class="n">emptySet</span>
     <span class="k">while</span> <span class="n">not</span> <span class="nf">empty</span><span class="o">(</span><span class="n">sorted</span><span class="o">)</span> <span class="n">and</span> <span class="n">sorted</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">a</span> <span class="o">=</span> <span class="n">key</span>
         <span class="n">insert</span> <span class="n">sorted</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="n">into</span> <span class="n">subset</span>
         <span class="n">remove</span> <span class="n">sorted</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</pre></div>


<p>merge join操作本身是非常快的，但是merge join前进行的排序可能会相当耗时</p>
<p>它首先根据R和S的join key分别对两张表进行排序，然后同时遍历排序后的R和S</p>
<p>其I/O复杂度可以表示为O[p(R) + p(S) + p(R) · logp(R) + p(S) · logp(S)]</p>
<p>附：归并排序是稳定排序，最好，最坏，平均时间复杂度均为O(nlogn)。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-06-28 09:36:13</p>
      </span>
    </div>

    
    
  </body>
</html>