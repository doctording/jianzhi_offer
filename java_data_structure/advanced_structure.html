<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>高级数据结构 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_data_structure">java_data_structure</a>&nbsp;&#187;&nbsp;高级数据结构
    <span class="updated">Page Updated&nbsp;
      2019-05-25 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">高级数据结构</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">高级数据结构</a><ul>
<li><a href="#hashhash">Hash表，Hash索引</a><ul>
<li><a href="#hash">hash索引的限制</a></li>
</ul>
</li>
<li><a href="#b-tree">B Tree</a><ul>
<li><a href="#_2">局部性原理与磁盘预读</a></li>
<li><a href="#io-b-tree">磁盘IO 与 B Tree 应用</a></li>
</ul>
</li>
<li><a href="#b-tree_1">B+ Tree</a><ul>
<li><a href="#_3">定义</a></li>
<li><a href="#b-tree_2">B+ tree 数据库索引</a><ul>
<li><a href="#b-tree_3">B+ tree 优势</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_4">红黑树</a></li>
<li><a href="#trie-tree">Trie Tree(字典树)</a></li>
<li><a href="#log-structured-merge-trees">Log Structured Merge Trees（日志结构的合并树）</a><ul>
<li><a href="#_5">磁盘的读写快慢问题</a></li>
<li><a href="#lsm-tree">LSM Tree 分析</a></li>
<li><a href="#_6">适用场景</a></li>
</ul>
</li>
<li><a href="#todo">// TODO</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="_1">高级数据结构</h1>
<h2 id="hashhash">Hash表，Hash索引</h2>
<p>数据库Hash索引参考：https://blog.csdn.net/olizxq/article/details/82313489</p>
<p>Hash索引不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash索引的查询效率要远高于 B-Tree 索引</p>
<h3 id="hash">hash索引的限制</h3>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li>
<li>哈希索引只支持等值比较查询，包括=、IN()、&lt;&gt;（注意&lt;&gt;和&lt;=&gt;是不同的操作）。也不支持任何范围查询，例如<code>WHERE price&gt;100</code>。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<h2 id="b-tree">B Tree</h2>
<p>多路搜索树, 关键字集合分布在整棵树中(非叶子节点和叶子节点都有关键字)</p>
<h3 id="_2">局部性原理与磁盘预读</h3>
<p>由于磁盘的存取速度与内存之间鸿沟,为了提高效率,要尽量减少磁盘I/O.磁盘往往不是严格按需读取，而是每次都会预读,磁盘读取完需要的数据,会顺序向后读一定长度的数据放入内存。</p>
<h3 id="io-b-tree">磁盘IO 与 B Tree 应用</h3>
<p>磁盘读取依靠的是机械运动，分为寻道时间、旋转延迟、传输时间三个部分，这三个部分耗时相加就是一次磁盘IO的时间</p>
<p>数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的节点。当访问一个地址数据的时候，与其相邻的数据很快也会被访问到。每次磁盘IO读取的数据我们称之为一页（page）。一页的大小与操作系统有关，一般为4k或者8k。这也就意味着读取一页内数据的时候，实际上发生了一次磁盘IO。</p>
<p>减少磁盘IO的次数就必须要压缩树的高度</p>
<p>B树主要应用于文件系统以及部分数据库索引</p>
<h2 id="b-tree_1">B+ Tree</h2>
<h3 id="_3">定义</h3>
<ul>
<li>树中每个非叶结点最多有 m 棵子树；</li>
<li>根结点 (非叶结点) 至少有 2 棵子树。除根结点外, 其它的非叶结点至少有 ém/2ù 棵子树；有 n 棵子树的非叶结点有 n-1 个关键码。</li>
<li>所有叶结点都处于同一层次上，包含了全部关键码及指向相应数据对象存放地址的指针，且叶结点本身按关键码从小到大顺序链接；</li>
<li>每个叶结点中的子树棵数 n 可以多于 m，可以少于 m，视关键码字节数及对象地址指针字节数而定。</li>
<li>若设结点可容纳最大关键码数为 m1，则指向对象的地址指针也有 m1 个。</li>
<li>结点中的子树棵数 n 应满足 n 属于[m1/2, m1]</li>
<li>若根结点同时又是叶结点，则结点格式同叶结点。</li>
<li>所有的非叶结点可以看成是索引部分，结点中关键码 Ki 与指向子树的指针 Pi 构成对子树 (即下一层索引块) 的索引项 ( Ki, Pi )，Ki 是子树中最小的关键码。</li>
<li>特别地，子树指针 P0 所指子树上所有关键码均小于 K1。结点格式同B树。</li>
<li>叶结点中存放的是对实际数据对象的索引。</li>
<li>
<p>在B+树中有两个头指针：一个指向B+树的根结点，一个指向关键码最小的叶结点。</p>
</li>
<li>
<p>B+ tree 与 B tree 的不同之处</p>
</li>
<li>
<p>所有关键字存储在叶子节点，非叶子节点不存储真正的data</p>
</li>
<li>为所有叶子节点增加了一个链指针</li>
</ul>
<h3 id="b-tree_2">B+ tree 数据库索引</h3>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_data_structure/imgs/BAddTree.png" /></p>
<h4 id="b-tree_3">B+ tree 优势</h4>
<ul>
<li>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大</p>
</li>
<li>
<p>B+树更适合外部存储,由于内节点无 data 域,一个结点可以存储更多的内结点,每个节点能索引的范围更大更精确,也意味着 B+树单次磁盘IO的信息量大于B-树,I/O效率更高。</p>
</li>
<li>
<p>关系数据库的区间访问是常见的一种情况，B+树叶节点增加的链指针,加强了区间访问性，可使用在范围区间查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找(或者说，B树的区间查找代价太大)。</p>
</li>
</ul>
<h2 id="_4">红黑树</h2>
<p>性质1. 节点是红色或黑色。<br />
性质2. 根节点是黑色。<br />
性质3. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br />
性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p><strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong></p>
<p>红黑树高度依然是平均log(n)，且最坏情况高度不会超过2log(n)。</p>
<p>任何不平衡都会在3次旋转之内解决， 红黑树能够以<code>O(log2(N))</code>的时间复杂度进行搜索、插入、删除操作</p>
<h2 id="trie-tree">Trie Tree(字典树)</h2>
<p>参考：https://blog.csdn.net/qq_26437925/article/category/5773761</p>
<h2 id="log-structured-merge-trees">Log Structured Merge Trees（日志结构的合并树）</h2>
<h3 id="_5">磁盘的读写快慢问题</h3>
<p>顺序读写磁盘（不管是SATA还是SSD）快于随机读写主存，而且快至少三个数量级</p>
<h3 id="lsm-tree">LSM Tree 分析</h3>
<h3 id="_6">适用场景</h3>
<h2 id="todo">// TODO</h2>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-11-03 21:33:44</p>
      </span>
    </div>

    
    
  </body>
</html>