<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>B/B+ Tree - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_data_structure">java_data_structure</a>&nbsp;&#187;&nbsp;B/B+ Tree
    <span class="updated">Page Updated&nbsp;
      2020-03-10 10:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">B/B+ Tree</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#b-tree">B Tree(多路搜索树)</a><ul>
<li><a href="#_1">磁盘相关</a></li>
</ul>
</li>
<li><a href="#b-tree_1">B+ Tree</a><ul>
<li><a href="#b">对比B树</a></li>
<li><a href="#_2">红黑树</a></li>
<li><a href="#hash">Hash</a><ul>
<li><a href="#hash_1">hash索引</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="b-tree">B Tree(多路搜索树)</h1>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_jvm/imgs/b_tree.png" /></p>
<ol>
<li>
<p>关键字集合分布在整颗树中</p>
</li>
<li>
<p>任何一个关键字出现且只出现在一个结点中</p>
</li>
<li>
<p>搜索有可能在非叶子结点结束</p>
</li>
<li>
<p>其搜索性能等价于在关键字全集内做一次二分查找</p>
</li>
</ol>
<h2 id="_1">磁盘相关</h2>
<p>磁盘读取依靠的是机械运动，分为<code>寻道时间</code>、<code>旋转延迟</code>、<code>传输时间</code>三个部分，这三个部分耗时相加就是一次磁盘IO的时间，大概9ms左右。这个成本是访问内存的10w倍左右</p>
<p>预读: 每一次IO时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到内存缓冲区中(程序局部性原理)</p>
<p>每次磁盘IO读取的数据我们称之为一页（page）。一页的大小与操作系统有关，一般为4k或者8k。这也就意味着读取一页内数据的时候，实际上发生了一次磁盘IO</p>
<p>数据库<code>索引</code>是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的节点</p>
<p><strong>减少磁盘IO</strong>的次数就必须要<strong>压缩树的高度</strong></p>
<h1 id="b-tree_1">B+ Tree</h1>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_jvm/imgs/BAddTree.png" /></p>
<ol>
<li>
<p>红点表示是指向卫星数据的指针，指针指向的是存放实际数据的磁盘页，卫星数据就是数据库中一条数据记录</p>
</li>
<li>
<p>叶子节点中还有一个指向下一个叶子节点的next指针，所以叶子节点形成了一个有序的链表，方便遍历B+树</p>
</li>
</ol>
<h2 id="b">对比B树</h2>
<p>a. 所有数据存在叶子节点，其它节点不存储数据，只存储索引。那么同样大小的磁盘页可以容纳更多的节点元素，如此一来，相同数量的数据下，B+树就相对来说要更加矮胖些，磁盘IO的次数更少。</p>
<p>b. 由于只有叶子节点才保存卫星数据，B+树每次查询都要到叶子节点；而B树每次查询则不一样，最好的情况是根节点，最坏的情况是叶子节点，没有B+树稳定</p>
<p>c. 叶子节点形成有顺链表，范围查找性能更优</p>
<h2 id="_2">红黑树</h2>
<p><code>O(logn)</code>时间内做<strong>查找</strong>，<strong>插入</strong>和<strong>删除</strong>操作</p>
<p>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树<strong>在最坏情况下</strong>都是高效的，而不同于普通的二叉查找树。</p>
<h2 id="hash">Hash</h2>
<h3 id="hash_1">hash索引</h3>
<p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快</p>
<p>对比<code>B+树</code></p>
<ul>
<li>
<p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据</p>
</li>
<li>
<p>如果是<strong>范围查询</strong>检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索</p>
</li>
<li>
<p>哈希索引也没办法利用索引完成排序，以及<code>like ‘xxx%’</code> 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）</p>
</li>
<li>
<p>哈希索引也不支持多列联合索引的最左匹配规则</p>
</li>
<li>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的<strong>哈希碰撞</strong>问题（如：Java8 <code>HashMap</code> 拉链法后又补充了<code>红黑树</code>转换）</p>
</li>
</ul>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-05-26 09:32:49</p>
      </span>
    </div>

    
    
  </body>
</html>