<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Java8 concurrent数据结构 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_data_structure">java_data_structure</a>&nbsp;&#187;&nbsp;Java8 concurrent数据结构
    <span class="updated">Page Updated&nbsp;
      2019-05-25 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Java8 concurrent数据结构</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#concurrent">concurrent数据结构</a><ul>
<li><a href="#concurrentmapinterface">ConcurrentMap(interface)</a></li>
<li><a href="#concurrenthashmapclass">ConcurrentHashMap(class)</a><ul>
<li><a href="#cas-synchronized">底层:数组+链表/红黑树，CAS + synchronized控制并发</a></li>
<li><a href="#put">put方法</a></li>
<li><a href="#size">获取size</a></li>
<li><a href="#java7">对比Java7分段锁优劣</a></li>
<li><a href="#java7_1">Java7分段锁的实现</a><ul>
<li><a href="#_1">锁粒度小</a></li>
<li><a href="#_2">扩容不足与改进</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#concurrentlinkedqueueclass">ConcurrentLinkedQueue(class) 无界线程安全</a></li>
<li><a href="#copyonwritearraylistclass">CopyOnWriteArrayList(class) 适合读多写少的并发场景</a><ul>
<li><a href="#addreentrantlock">add方法使用ReentrantLock</a></li>
<li><a href="#_3">缺点</a></li>
</ul>
</li>
<li><a href="#copyonwritearraysetclass-copyonwritearraylist">CopyOnWriteArraySet(class 基于 CopyOnWriteArrayList)</a></li>
<li><a href="#arrayblockingqueueclass">ArrayBlockingQueue(class) 基于数组的阻塞队列</a></li>
<li><a href="#linkedblockingdequeclass">LinkedBlockingDeque(class) 基于链表的阻塞队列</a><ul>
<li><a href="#_4">链表</a></li>
<li><a href="#put_1">put方法，添加元素</a></li>
<li><a href="#offer">offer方法，添加元素</a></li>
</ul>
</li>
<li><a href="#take">take 方法，取元素</a><ul>
<li><a href="#linkedblockingqueue">基于LinkedBlockingQueue的生产者和消费者</a></li>
</ul>
</li>
<li><a href="#todo">TODO</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="concurrent"><code>concurrent</code>数据结构</h1>
<h2 id="concurrentmapinterface">ConcurrentMap(interface)</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ConcurrentMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</pre></div>


<h2 id="concurrenthashmapclass">ConcurrentHashMap(class)</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;,</span> <span class="n">Serializable</span> <span class="o">{</span>
</pre></div>


<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_data_structure/imgs/concurrent_hashmap.png" /></p>
<p>每个桶可能是<code>链表</code>结构或者<code>红黑树</code>结构，锁针对桶的头节点加，<code>锁粒度小</code></p>
<h3 id="cas-synchronized">底层:数组+链表/红黑树，CAS + synchronized控制并发</h3>
<div class="hlcode"><pre> <span class="cm">/* ---------------- Fields -------------- */</span>

<span class="cm">/**</span>
<span class="cm">    * The array of bins. Lazily initialized upon first insertion.</span>
<span class="cm">    * Size is always a power of two. Accessed directly by iterators.</span>
<span class="cm">    */</span>
<span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">    * The next table to use; non-null only while resizing.</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">nextTable</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">    * Base counter value, used mainly when there is no contention,</span>
<span class="cm">    * but also as a fallback during table initialization</span>
<span class="cm">    * races. Updated via CAS.</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">baseCount</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">    * Table initialization and resizing control.  When negative, the</span>
<span class="cm">    * table is being initialized or resized: -1 for initialization,</span>
<span class="cm">    * else -(1 + the number of active resizing threads).  Otherwise,</span>
<span class="cm">    * when table is null, holds the initial table size to use upon</span>
<span class="cm">    * creation, or 0 for default. After initialization, holds the</span>
<span class="cm">    * next element count value upon which to resize the table.</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">sizeCtl</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">    * The next table index (plus one) to split while resizing.</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">transferIndex</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">    * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">cellsBusy</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">    * Table of counter cells. When non-null, size is a power of 2.</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">CounterCell</span><span class="o">[]</span> <span class="n">counterCells</span><span class="o">;</span>

<span class="c1">// views</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="n">KeySetView</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">keySet</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="n">ValuesView</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="n">EntrySetView</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">entrySet</span><span class="o">;</span>
</pre></div>


<h3 id="put">put方法</h3>
<div class="hlcode"><pre><span class="cm">/** Implementation for put and putIfAbsent */</span>
<span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// key, value 都不能为null</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">spread</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">fh</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">initTable</span><span class="o">();</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// CAS方式进行添加结点</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">casTabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span>
                            <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">)))</span>
                <span class="k">break</span><span class="o">;</span>                   <span class="c1">// no lock when adding to empty bin</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">fh</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">==</span> <span class="n">MOVED</span><span class="o">)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">helpTransfer</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">f</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">V</span> <span class="n">oldVal</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="c1">// synchronized 同步操作</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">fh</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">binCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">;;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">K</span> <span class="n">ek</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                                <span class="o">((</span><span class="n">ek</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                                    <span class="o">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ek</span><span class="o">))))</span> <span class="o">{</span>
                                <span class="n">oldVal</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                                <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span>
                                    <span class="n">e</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                                <span class="k">break</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span>
                                                            <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                                <span class="k">break</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">f</span> <span class="k">instanceof</span> <span class="n">TreeBin</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>
                        <span class="n">binCount</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeBin</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">f</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span>
                                                        <span class="n">value</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">oldVal</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span><span class="o">)</span>
                                <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span><span class="o">)</span>
                    <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">oldVal</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">oldVal</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">addCount</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">binCount</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<ol>
<li>
<p>先判断key和value是否为null，为null则抛出异常</p>
</li>
<li>
<p>判断table是否初始化，如果没有则进行初始化</p>
</li>
<li>
<p>计算key的hash值，并得到插入的数组索引。</p>
</li>
<li>
<p>找到table[i]的位置，如果为null直接插入，如果不为null判断此key是否存在，如果存在直接覆盖，如果不存在进行判断如果head节点是树节点，按照红黑树的方式插入新的节点，如果不是则按照链表的方式插入，同时会判断当前的链表长度是否大于<code>TREEIFY_THRESHOLD=8</code>，如果大于则转为红黑树再插入，否则直接插入，插入采用的CAS自旋的方式。</p>
</li>
<li>
<p>最后判断table的size是否需要扩容，如果需要则扩容，否则就结束。在扩容的时候会在链表头部插入forward，如果其他线程检测到需要插入的位置被forward节点占有，就帮助进行扩容。</p>
</li>
</ol>
<h3 id="size">获取size</h3>
<div class="hlcode"><pre> <span class="cm">/**</span>
<span class="cm">    * Returns the number of mappings. This method should be used</span>
<span class="cm">    * instead of {@link #size} because a ConcurrentHashMap may</span>
<span class="cm">    * contain more mappings than can be represented as an int. The</span>
<span class="cm">    * value returned is an estimate; the actual count may differ if</span>
<span class="cm">    * there are concurrent insertions or removals.</span>
<span class="cm">    *</span>
<span class="cm">    * @return the number of mappings</span>
<span class="cm">    * @since 1.8</span>
<span class="cm">    */</span>
<span class="kd">public</span> <span class="kt">long</span> <span class="nf">mappingCount</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sumCount</span><span class="o">();</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0L</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0L</span> <span class="o">:</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// ignore transient negative values</span>
<span class="o">}</span>
</pre></div>


<p>一个大概的数值，因为可能在统计的时候有其他线程正在执行插入或删除操作</p>
<h3 id="java7">对比Java7分段锁优劣</h3>
<h3 id="java7_1">Java7分段锁的实现</h3>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_data_structure/imgs/concurrent_segment.png" /></p>
<p>eg, <code>new ConcurrentHashMap()</code>:</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null</li>
<li>put操作是，先根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了</li>
</ul>
<h4 id="_1">锁粒度小</h4>
<p>只需要锁住这个链表/红黑树的head节点，并不会影响其他的table元素的读写，影响更小</p>
<h4 id="_2">扩容不足与改进</h4>
<ul>
<li>
<p>在于并发扩容的时候，由于操作的table都是同一个，不像JDK7中分段控制，所以这里需要等扩容完之后，所有的读写操作才能进行，所以扩容的效率就成为了整个并发的一个瓶颈点</p>
</li>
<li>
<p>引入了一个ForwardingNode类，在一个线程发起扩容的时候，就会改变<code>sizeCtl</code>这个值</p>
</li>
</ul>
<div class="hlcode"><pre><span class="n">sizeCtl</span> <span class="err">：默认为</span><span class="mi">0</span><span class="err">，用来控制</span><span class="n">table</span><span class="err">的初始化和扩容操作，具体应用在后续会体现出来。</span>
<span class="o">-</span><span class="mi">1</span> <span class="err">代表</span><span class="n">table</span><span class="err">正在初始化</span>
<span class="o">-</span><span class="n">N</span> <span class="err">表示有</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="err">个线程正在进行扩容操作</span>
<span class="err">其余情况：</span>
<span class="mi">1</span><span class="err">、如果</span><span class="n">table</span><span class="err">未初始化，表示</span><span class="n">table</span><span class="err">需要初始化的大小。</span>
<span class="mi">2</span><span class="err">、如果</span><span class="n">table</span><span class="err">初始化完成，表示</span><span class="n">table</span><span class="err">的容量，默认是</span><span class="n">table</span><span class="err">大小的</span><span class="mf">0.75</span><span class="err">倍</span>
</pre></div>


<p>扩容时候会判断这个值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd，如果f == null，则在table中的i位置放入fwd，否则采用头插法的方式把当前旧table数组的指定任务范围的数据给迁移到新的数组中，然后 给旧table原位置赋值fwd。直到遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断head节点是否为forwardNode节点，如果是就帮助扩容。</p>
<ul>
<li>参考</li>
</ul>
<p>作者：葬月魔帝<br />
来源：CSDN<br />
原文：<a href="https://blog.csdn.net/u010454030/article/details/82458413" target="_blank">理解Java7和8里面HashMap+ConcurrentHashMap的扩容策略<br />
</a></p>
<p>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<h2 id="concurrentlinkedqueueclass">ConcurrentLinkedQueue(class) 无界线程安全</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentLinkedQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">196745693267521676L</span><span class="o">;</span>
</pre></div>


<h2 id="copyonwritearraylistclass">CopyOnWriteArrayList(class) 适合读多写少的并发场景</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">RandomAccess</span><span class="o">,</span> <span class="n">Cloneable</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</pre></div>


<ul>
<li>CopyOnWriteArrayList是线程安全的<code>ArrayList</code>, 读方法不加锁，写方法加锁</li>
<li>读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array</li>
<li>如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的</li>
<li>volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变 化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</li>
</ul>
<h3 id="addreentrantlock">add方法使用<code>ReentrantLock</code></h3>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Object</span><span class="o">[]</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">getArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">Object</span><span class="o">[]</span> <span class="n">newElements</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">newElements</span><span class="o">[</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
        <span class="n">setArray</span><span class="o">(</span><span class="n">newElements</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3 id="_3">缺点</h3>
<ul>
<li>内存占用问题</li>
</ul>
<p>因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<ul>
<li>数据一致性问题(只保证<code>最终一致性</code>)</li>
</ul>
<p>CopyOnWrite容器只能保证数据的<code>最终一致性</code>，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<h2 id="copyonwritearraysetclass-copyonwritearraylist">CopyOnWriteArraySet(class 基于 CopyOnWriteArrayList)</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyOnWriteArraySet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">5457747651344034263L</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">al</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Creates an empty set.</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">CopyOnWriteArraySet</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">al</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;();</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Creates a set containing all of the elements of the specified</span>
<span class="cm">     * collection.</span>
<span class="cm">     *</span>
<span class="cm">     * @param c the collection of elements to initially contain</span>
<span class="cm">     * @throws NullPointerException if the specified collection is null</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">CopyOnWriteArraySet</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="n">CopyOnWriteArraySet</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&quot;unchecked&quot;</span><span class="o">)</span> <span class="n">CopyOnWriteArraySet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">cc</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">CopyOnWriteArraySet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;)</span><span class="n">c</span><span class="o">;</span>
            <span class="n">al</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;(</span><span class="n">cc</span><span class="o">.</span><span class="na">al</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">al</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;();</span>
            <span class="n">al</span><span class="o">.</span><span class="na">addAllAbsent</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></div>


<p>add操作采用<code>CopyOnWriteArrayList</code>的<code>addIfAbsent</code>方法，加了锁保护，并创建一个新的Object数组；每次add都要进行数组的遍历，性能低</p>
<h2 id="arrayblockingqueueclass">ArrayBlockingQueue(class) 基于数组的阻塞队列</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayBlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</pre></div>


<p>基于数组，先进先出，现场安全的集合类，特点是：可执行时间的阻塞读写，并且容量有限</p>
<h2 id="linkedblockingdequeclass">LinkedBlockingDeque(class) 基于链表的阻塞队列</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedBlockingDeque</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
    <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="n">BlockingDeque</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</pre></div>


<h3 id="_4">链表</h3>
<div class="hlcode"><pre><span class="cm">/**</span>
<span class="cm">* Linked list node class</span>
<span class="cm">*/</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">E</span> <span class="n">item</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">        * One of:</span>
<span class="cm">        * - the real successor Node</span>
<span class="cm">        * - this Node, meaning the successor is head.next</span>
<span class="cm">        * - null, meaning there is no successor (this is the last node)</span>
<span class="cm">        */</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

    <span class="n">Node</span><span class="o">(</span><span class="n">E</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">item</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/** The capacity bound, or Integer.MAX_VALUE if none */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

<span class="cm">/** Current number of elements */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">();</span>

<span class="cm">/**</span>
<span class="cm">    * Head of linked list.</span>
<span class="cm">    * Invariant: head.item == null</span>
<span class="cm">    */</span>
<span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">head</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">    * Tail of linked list.</span>
<span class="cm">    * Invariant: last.next == null</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">last</span><span class="o">;</span>
</pre></div>


<h3 id="put_1">put方法，添加元素</h3>
<div class="hlcode"><pre><span class="cm">/**</span>
<span class="cm">    * Inserts the specified element at the tail of this queue, waiting if</span>
<span class="cm">    * necessary for space to become available.</span>
<span class="cm">    *</span>
<span class="cm">    * @throws InterruptedException {@inheritDoc}</span>
<span class="cm">    * @throws NullPointerException {@inheritDoc}</span>
<span class="cm">    */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="c1">// Note: convention in all put/take/etc is to preset local var</span>
    <span class="c1">// holding count negative to indicate failure unless set.</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;(</span><span class="n">e</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">putLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">putLock</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
    <span class="n">putLock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="cm">/*</span>
<span class="cm">            * Note that count is used in wait guard even though it is</span>
<span class="cm">            * not protected by lock. This works because count can</span>
<span class="cm">            * only decrease at this point (all other puts are shut</span>
<span class="cm">            * out by lock), and we (or some other waiting put) are</span>
<span class="cm">            * signalled if it ever changes from capacity. Similarly</span>
<span class="cm">            * for all other uses of count in other wait guards.</span>
<span class="cm">            */</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">notFull</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">enqueue</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="o">)</span>
            <span class="n">notFull</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">putLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">signalNotEmpty</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>


<p>使用了<code>ReentrantLock</code>,若向队尾添加元素的时候发现队列已经满了会发生阻塞一直等待空间，以加入元素。</p>
<h3 id="offer">offer方法，添加元素</h3>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">nanos</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">putLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">putLock</span><span class="o">;</span>
        <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
        <span class="n">putLock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">nanos</span> <span class="o">=</span> <span class="n">notFull</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">nanos</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">enqueue</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;(</span><span class="n">e</span><span class="o">));</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="o">)</span>
                <span class="n">notFull</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">putLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">signalNotEmpty</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<p>如果发现队列已满无法添加的话，等待指定时间后会直接返回false</p>
<h2 id="take">take 方法，取元素</h2>
<div class="hlcode"><pre><span class="kd">public</span> <span class="n">E</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="n">E</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">takeLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">takeLock</span><span class="o">;</span>
    <span class="n">takeLock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">notEmpty</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">dequeue</span><span class="o">();</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">getAndDecrement</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
            <span class="n">notEmpty</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">takeLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span>
        <span class="n">signalNotFull</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>若队列为空，则发生阻塞，一直等待有元素</p>
<h3 id="linkedblockingqueue">基于<code>LinkedBlockingQueue</code>的生产者和消费者</h3>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.LinkedBlockingQueue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Basket</span><span class="o">{</span>
    <span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">linkedBlockingQueue</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Basket</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">){</span>
        <span class="n">linkedBlockingQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;(</span><span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addToBasket</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
        <span class="n">linkedBlockingQueue</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getFromBasket</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">{</span>
        <span class="k">return</span> <span class="n">linkedBlockingQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Producer</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">Basket</span> <span class="n">basket</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">Basket</span> <span class="n">basket</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">basket</span> <span class="o">=</span> <span class="n">basket</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">produce</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">basket</span><span class="o">.</span><span class="na">addToBasket</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">basket</span><span class="o">.</span><span class="na">linkedBlockingQueue</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Consumer</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">Basket</span> <span class="n">basket</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">Basket</span> <span class="n">basket</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">basket</span> <span class="o">=</span> <span class="n">basket</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">consume</span><span class="o">(){</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">basket</span><span class="o">.</span><span class="na">getFromBasket</span><span class="o">();</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">basket</span><span class="o">.</span><span class="na">linkedBlockingQueue</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">Basket</span> <span class="n">basket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Basket</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">Producer</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Producer</span><span class="o">(</span><span class="n">basket</span><span class="o">);</span>
        <span class="n">Consumer</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Consumer</span><span class="o">(</span><span class="n">basket</span><span class="o">);</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span><span class="o">{</span>
                    <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
                <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>

                <span class="o">}</span>
                <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="n">r</span><span class="o">;</span>
                <span class="n">producer</span><span class="o">.</span><span class="na">produce</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&quot;produce:&quot;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot; queue: &quot;</span><span class="o">);</span>
                <span class="n">producer</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>

                <span class="o">}</span>
                <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">consume</span><span class="o">();</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&quot;consumer:&quot;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot; queue: &quot;</span><span class="o">);</span>
                <span class="n">consumer</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<h2 id="todo">TODO</h2>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-06-16 20:57:45</p>
      </span>
    </div>

    
    
  </body>
</html>