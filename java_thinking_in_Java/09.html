<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>《Java编程思想》第9章：接口 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_thinking_in_Java">java_thinking_in_Java</a>&nbsp;&#187;&nbsp;《Java编程思想》第9章：接口
    <span class="updated">Page Updated&nbsp;
      2019-02-12 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">《Java编程思想》第9章：接口</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">概述</a><ul>
<li><a href="#_2">抽象方法和抽象类</a></li>
<li><a href="#interface">接口（interface）</a></li>
<li><a href="#_3">接口与工厂</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="_1">概述</h1>
<p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法</p>
<h2 id="_2">抽象方法和抽象类</h2>
<p>包含<code>抽象方法</code>的类叫做<code>抽象类</code>。如果一个类包含一个或者多个抽象方法，该类必须被限定为<code>抽象的</code></p>
<p>抽象方法：只有声明，没有方法体, eg:</p>
<div class="hlcode"><pre><span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">();</span>
</pre></div>


<p>抽象类和普通类的主要有三点区别：</p>
<ol>
<li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li>
<li>抽象类不能用来创建对像，即无法实例化</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类</li>
</ol>
<h2 id="interface">接口（interface）</h2>
<p>接口，是对行为的抽象，一般为实现xx接口; Java继承是单继承, 而实现接口是可以实现多个接口的</p>
<div class="hlcode"><pre><span class="kd">class</span> <span class="nc">ClassName</span> <span class="kd">implements</span> <span class="n">Interface1</span><span class="o">,</span><span class="n">Interface2</span><span class="o">,[....]{</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>
<p>与<code>抽象类</code>语法层面上的区别</p>
</li>
<li>
<p>抽象类可以提供成员方法的实现细节，而接口中只能存在<code>public abstract</code>方法(默认就是，前面加上修饰词会提示多余)</p>
</li>
<li>
<p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是<code>public static final</code>类型的(默认就是，前面加上修饰词会提示多余)；</p>
</li>
<li>
<p>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p>
</li>
<li>
<p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
<li>
<p>与<code>抽象类</code>设计层面上的区别</p>
</li>
<li>
<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</p>
</li>
<li>
<p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计</p>
</li>
</ul>
<p>参考1 ：<br />
作者：海子<br />
出处：http://www.cnblogs.com/dolphin0520/</p>
<h2 id="_3">接口与工厂</h2>
<p>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是<code>工厂方法</code>设计模式。这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离</p>
<div class="hlcode"><pre><span class="kd">interface</span> <span class="nc">Cycle</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">wheels</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">CycleFactory</span> <span class="o">{</span>
    <span class="n">Cycle</span> <span class="nf">getCycle</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Unicycle</span> <span class="kd">implements</span> <span class="n">Cycle</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">wheels</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">UnicycleFactory</span> <span class="kd">implements</span> <span class="n">CycleFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Unicycle</span> <span class="nf">getCycle</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Unicycle</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Bicycle</span> <span class="kd">implements</span> <span class="n">Cycle</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">wheels</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="mi">2</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">BicycleFactory</span> <span class="kd">implements</span> <span class="n">CycleFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Bicycle</span> <span class="nf">getCycle</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Bicycle</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Tricycle</span> <span class="kd">implements</span> <span class="n">Cycle</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">wheels</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="mi">3</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TricycleFactory</span> <span class="kd">implements</span> <span class="n">CycleFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Tricycle</span> <span class="nf">getCycle</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Tricycle</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">ride</span><span class="o">(</span><span class="n">CycleFactory</span> <span class="n">fact</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Cycle</span> <span class="n">c</span> <span class="o">=</span> <span class="n">fact</span><span class="o">.</span><span class="na">getCycle</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Num. of wheels: &quot;</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">wheels</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ride</span><span class="o">(</span><span class="k">new</span> <span class="n">UnicycleFactory</span><span class="o">());</span>
        <span class="n">ride</span><span class="o">(</span><span class="k">new</span> <span class="n">BicycleFactory</span> <span class="o">());</span>
        <span class="n">ride</span><span class="o">(</span><span class="k">new</span> <span class="n">TricycleFactory</span> <span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* Output:</span>
<span class="cm"> Num. of wheels: 1</span>
<span class="cm"> Num. of wheels: 2</span>
<span class="cm"> Num. of wheels: 3</span>
<span class="cm"> */</span><span class="c1">//:~</span>
</pre></div>


<p>如果不用工厂方法，就必须在某处指定将要创建的Cycle的确切类型，以便调用合适的构造器</p>
<p>参考：<br />
http://www.runoob.com/design-pattern/factory-pattern.html</p>
<ol>
<li>
<p>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现</p>
</li>
<li>
<p>Hibernate 换数据库只需换方言和驱动就可以</p>
</li>
</ol>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-03-20 23:15:11</p>
      </span>
    </div>

    
    
  </body>
</html>