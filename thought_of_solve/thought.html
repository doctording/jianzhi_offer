<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>剑指Offer解题思路(全) - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#thought_of_solve">thought_of_solve</a>&nbsp;&#187;&nbsp;剑指Offer解题思路(全)
    <span class="updated">Page Updated&nbsp;
      2018-05-30 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">剑指Offer解题思路(全)</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1">1 二维数组中的查找</a></li>
<li><a href="#2">2 替换空格</a></li>
<li><a href="#3">3 从尾到头打印链表</a></li>
<li><a href="#4">4 重建二叉树</a></li>
<li><a href="#5">5 用两个栈实现队列</a></li>
<li><a href="#6">6 旋转数组的最小数字</a></li>
<li><a href="#7-import">7 斐波那契数列 (import)</a></li>
<li><a href="#8">8 跳台阶</a></li>
<li><a href="#9">9 变态跳台阶</a></li>
<li><a href="#10">10 矩形覆盖</a></li>
<li><a href="#11-1">11 二进制中1的个数</a></li>
<li><a href="#12">12 数值的整数次方</a></li>
<li><a href="#13-important">13 调整数组顺序使奇数位于偶数前面 （important）</a></li>
<li><a href="#14-k">14 链表中倒数第k个结点</a></li>
<li><a href="#15">15 反转链表</a></li>
<li><a href="#16">16 合并两个排序的链表</a></li>
<li><a href="#17-important">17 树的子结构（important）</a></li>
<li><a href="#18">18 二叉树的镜像</a></li>
<li><a href="#19">19 顺时针打印矩阵</a></li>
<li><a href="#20-min">20 包含min函数的栈</a></li>
<li><a href="#21">21 栈的压入、弹出序列</a></li>
<li><a href="#22">22 从上往下打印二叉树</a></li>
<li><a href="#23">23 二叉搜索树的后序遍历序列</a></li>
<li><a href="#24">24 二叉树中和为某一值的路径</a></li>
<li><a href="#25-important">25 复杂链表的复制 (important)</a></li>
<li><a href="#26">26 二叉搜索树与双向链表</a></li>
<li><a href="#27">27 字符串的排列</a></li>
<li><a href="#28">28 数组中出现次数超过一半的数字</a></li>
<li><a href="#29-k">29 最小的K个数</a></li>
<li><a href="#30">30 连续子数组的最大和</a></li>
<li><a href="#31-11n1">31 整数中1出现的次数（从1到n整数中1出现的次数）</a></li>
<li><a href="#32">32 把数组排成最小的数</a></li>
<li><a href="#33">33 丑数</a></li>
<li><a href="#34">34 第一个只出现一次的字符</a></li>
<li><a href="#35-important">35 数组中的逆序对（important）</a></li>
<li><a href="#36">36 两个链表的第一个公共结点</a></li>
<li><a href="#37">37 数字在排序数组中出现的次数</a></li>
<li><a href="#38">38 二叉树的深度</a></li>
<li><a href="#39">39 输入一棵二叉树，判断该二叉树是否是平衡二叉树</a></li>
<li><a href="#40">40 数组中只出现一次的数字</a></li>
<li><a href="#41-simportant">41 和为S的连续正数序列（important）</a></li>
<li><a href="#42-s">42 和为S的两个数字</a></li>
<li><a href="#43">43 左旋转字符串</a></li>
<li><a href="#44">44 翻转单词顺序列</a></li>
<li><a href="#45">45 扑克牌顺子</a></li>
<li><a href="#46">46 孩子们的游戏(圆圈中最后剩下的数)</a></li>
<li><a href="#47-123n">47 求1+2+3+...+n</a></li>
<li><a href="#48">48 不用加减乘除做加法</a></li>
<li><a href="#49-important">49 把字符串转换成整数 (important)</a></li>
<li><a href="#50">50 数组中重复的数字</a></li>
<li><a href="#51">51 构建乘积数组</a></li>
<li><a href="#52-important">52 正则表达式匹配(important)</a></li>
<li><a href="#53">53 表示数值的字符串</a></li>
<li><a href="#54">54 字符流中第一个不重复的字符</a></li>
<li><a href="#55">55 链表中环的入口结点</a></li>
<li><a href="#56">56 删除链表中重复的结点</a></li>
<li><a href="#57">57 二叉树的下一个结点， 中序遍历顺序的下一个结点并且返回</a></li>
<li><a href="#58">58 对称的二叉树</a></li>
<li><a href="#59">59 按之字形顺序打印二叉树</a></li>
<li><a href="#60">60 把二叉树打印成多行</a></li>
<li><a href="#61">61 序列化二叉树</a></li>
<li><a href="#62-k">62 二叉搜索树的第k个结点</a></li>
<li><a href="#63">63 数据流中的中位数</a></li>
<li><a href="#64">64 滑动窗口的最大值</a></li>
<li><a href="#65">65 矩阵中的路径</a></li>
<li><a href="#66">66 机器人的运动范围</a></li>
<li><a href="#67">67 剪绳子</a></li>
</ul>
</div>
<h1 id="1">1 二维数组中的查找</h1>
<ul>
<li>有序查找</li>
<li>二分</li>
</ul>
<h1 id="2">2 替换空格</h1>
<ul>
<li>先统计增大的空间，然后从后往前替换</li>
</ul>
<h1 id="3">3 从尾到头打印链表</h1>
<ul>
<li>
<p>头插法将链表反转一下，然后遍历（这种方式会改变链表的结构）</p>
</li>
<li>
<p>当链表只读时，采用递归的方法（栈）来操作，就可以实现链表数据的反转了</p>
</li>
</ul>
<h1 id="4">4 重建二叉树</h1>
<ul>
<li>这类题目都采用递归，属于二叉树基础题</li>
</ul>
<h1 id="5">5 用两个栈实现队列</h1>
<ul>
<li>保持一个stack为空，通过两个栈转储，实现数据进出是队列形式的</li>
</ul>
<h1 id="6">6 旋转数组的最小数字</h1>
<ul>
<li>
<p>头尾往中间逼近的方法,直接遍历一遍，O(n)的做法，显然太low</p>
</li>
<li>
<p>二分查找的方法，不过有特殊情况，比如 [1 0 1 1 1] ，[1 1 1 0 1] 这种，需要单独顺序遍历</p>
</li>
</ul>
<h1 id="7-import">7 斐波那契数列 (<em>import</em>)</h1>
<ul>
<li>
<p>最直接的递归/动归， O(2^n), n的指数次方增长</p>
</li>
<li>
<p>利用变量,非递归，时间复杂度O(n)</p>
</li>
<li>
<p>快速幂的做法  f(n) = f(n - 1) + f(n - 2), 二阶的快速幂，时间复杂度O(logn),需要推算一下矩阵公式</p>
</li>
</ul>
<h1 id="8">8 跳台阶</h1>
<ul>
<li>同 斐波那契数列</li>
</ul>
<h1 id="9">9 变态跳台阶</h1>
<p>数学公式推导, 同斐波那契数列</p>
<h1 id="10">10 矩形覆盖</h1>
<ul>
<li>同 斐波那契数列</li>
</ul>
<h1 id="11-1">11 二进制中1的个数</h1>
<ul>
<li>经典问题，采用位运算<code>n &amp; (n-1)</code>得到最右边的一个1</li>
</ul>
<h1 id="12">12 数值的整数次方</h1>
<ul>
<li>
<p>快速幂方法</p>
</li>
<li>
<p>边界，符号，double/float判零问题</p>
</li>
<li>
<p>位运算比除法，取模等效率高</p>
</li>
</ul>
<h1 id="13-important">13 调整数组顺序使奇数位于偶数前面 （<em>important</em>）</h1>
<ul>
<li>
<p>注意题目要求无序和有序的区别</p>
</li>
<li>
<p>无序</p>
<ol>
<li>快排思路，维持头/尾两个指针，不断的交换到相遇,时间O(n), 空间O(1)</li>
</ol>
</li>
<li>
<p>要求保持数据相对位置不变(无序的最优解不再满足需求，注意快排是不稳定的)</p>
<ol>
<li>直接插入排序， 时间复杂度O(n^2), 空间复杂度O(1)</li>
<li>归并排序， 时间复杂度O(nlogn), 空间复杂度O(n) ?；归并排序是稳定的排序，归并排序需要O(n)的辅助空间</li>
<li>利用复杂空间，空间复杂度O(n), 时间复杂度O(n)（直接遍历一遍）</li>
</ol>
</li>
</ul>
<h1 id="14-k">14 链表中倒数第k个结点</h1>
<ul>
<li>两个指针，保持距离k；那么一个链表尾部，一个就是倒数k</li>
</ul>
<h1 id="15">15 反转链表</h1>
<ul>
<li>直接遍历，头插法</li>
<li>递归法</li>
</ul>
<h1 id="16">16 合并两个排序的链表</h1>
<ul>
<li>
<p>每个链表一个游标，边比较/边连接，最后多的直接连接</p>
</li>
<li>
<p>递归思路，因为链表总是有序的，对两个链表头节点处理后，剩下的操作更前面的一样的</p>
</li>
</ul>
<h1 id="17-important">17 树的子结构（<em>important</em>）</h1>
<ul>
<li>注意<code>子结构</code>和<code>子树</code>的区别</li>
</ul>
<p><strong>子树</strong>的意思是包含了一个结点，就得包含这个结点下的所有节点，一棵大小为n的二叉树有n个子树，就是分别以每个结点为根的子树。</p>
<p><strong>子结构</strong>的意思是包含了一个结点，可以只取左子树或者右子树，或者都不取。</p>
<ul>
<li>子树问题 可以采用 序列化方法，而子结构不能采用序列化方法</li>
</ul>
<p>此题 递归求解，要么根，要么与左子树匹配，要么与右子树匹配，递归需要注意</p>
<h1 id="18">18 二叉树的镜像</h1>
<p>递归： 子树先镜像，然后上层根再镜像</p>
<h1 id="19">19 顺时针打印矩阵</h1>
<ul>
<li>一圈一圈的打印，可以封装成一个方法</li>
</ul>
<h1 id="20-min">20 包含min函数的栈</h1>
<ul>
<li>
<p>辅助栈方法</p>
<ol>
<li>维持两个栈，一个普通栈，一个存放min的栈，两个栈对应起来</li>
</ol>
</li>
<li>
<p>不用辅助栈</p>
<ol>
<li>push(int elem)函数在栈中压入当前元素与当前栈中最小元素的差值，然后通过比较当前元素与当前栈中最小元素大小，并将它们中间的较小值压入。</li>
<li>pop()函数执行的时候，先pop出栈顶的两个值，这两个值分别是当前栈中最小值min和最后压入的元素与栈中最小值的差值diff</li>
</ol>
</li>
</ul>
<h1 id="21">21 栈的压入、弹出序列</h1>
<ul>
<li>直接利用STL stack等结构, 去模拟栈的压入、弹出过程</li>
</ul>
<h1 id="22">22 从上往下打印二叉树</h1>
<ul>
<li>直接层次遍历</li>
</ul>
<h1 id="23">23 二叉搜索树的后序遍历序列</h1>
<ul>
<li>判断后续是否合法</li>
<li>问清楚有没有重复数字，搜索树是怎样的排序</li>
<li>根据后序：左 右 根的顺序，递归判断是否满足二叉树的大小关系</li>
</ul>
<h1 id="24">24 二叉树中和为某一值的路径</h1>
<p>DFS 或 BFS</p>
<h1 id="25-important">25 复杂链表的复制 (<em>important</em>)</h1>
<p>next 和 random</p>
<p>首先<code>A B C D</code> 变成  <code>A A' B B' C C' D D'</code></p>
<p>通过1，则有：<code>A'.random</code> = <code>A.random.next</code></p>
<p>然后遍历改变<code>random</code>, 遍历改变<code>next</code>，最后输出即可</p>
<h1 id="26">26 二叉搜索树与双向链表</h1>
<ul>
<li>二叉树的非递归遍历(可以使用辅助栈)</li>
</ul>
<h1 id="27">27 字符串的排列</h1>
<ul>
<li>递归法，需要判断重复的串</li>
<li>可排序，然后判断，也可以采用set等数据结构</li>
</ul>
<h1 id="28">28 数组中出现次数超过一半的数字</h1>
<ul>
<li>cur, count，（每次取两个不一样的数删除)　最后验证</li>
</ul>
<h1 id="29-k">29 最小的K个数</h1>
<ul>
<li>
<p>快排思路</p>
</li>
<li>
<p>堆排序思路 O(nlogk)时间复杂度，适合处理海量数据,采用红黑树（stl中的set,multiset都是基于红黑树的）</p>
</li>
</ul>
<h1 id="30">30 连续子数组的最大和</h1>
<ul>
<li>动态规划</li>
</ul>
<h1 id="31-11n1">31 整数中1出现的次数（从1到n整数中1出现的次数）</h1>
<ul>
<li>
<p>遍历1到n,对每个数采用mod 10 取得1的个数，时间复杂度达到O(nlogn)</p>
</li>
<li>
<p>找规律的方法，时间复杂度达到O(logn), 参考如下的讲解<br />
http://blog.csdn.net/yi_afly/article/details/52012593</p>
</li>
</ul>
<h1 id="32">32 把数组排成最小的数</h1>
<ul>
<li>两两组合排序，注意0</li>
</ul>
<h1 id="33">33 丑数</h1>
<h1 id="34">34 第一个只出现一次的字符</h1>
<ul>
<li>
<p>直接求解：每个字符都与后面的字符比较:空间O(1), 时间(O(n^2)</p>
</li>
<li>
<p>hash记录，空间O(n), 时间O(n)</p>
</li>
</ul>
<h1 id="35-important">35 数组中的逆序对（<em>important</em>）</h1>
<ul>
<li>
<p>直接求解： 时间复杂度是O(n^2)</p>
</li>
<li>
<p>归并排序思路：O(n)的空间，时间复杂度为O(nlogn)</p>
</li>
</ul>
<h1 id="36">36 两个链表的第一个公共结点</h1>
<ul>
<li>
<p>单链表是否存在环<br />
 走一步，走两步,进一步可以找到第一个公共节点</p>
</li>
<li>
<p>直接利用map</p>
</li>
<li>
<p>将两个链表先处理成一样长的，然后再判断</p>
</li>
</ul>
<h1 id="37">37 数字在排序数组中出现的次数</h1>
<ul>
<li>二分查找，然后左右扩散开统计</li>
</ul>
<h1 id="38">38 二叉树的深度</h1>
<ul>
<li>
<p>递归</p>
</li>
<li>
<p>非递归实现(可以层次遍历)</p>
</li>
</ul>
<h1 id="39">39 输入一棵二叉树，判断该二叉树是否是平衡二叉树</h1>
<ol>
<li>
<p>每个节点都采用求深度的方法，这样遍历求解，重复计算量太大</p>
</li>
<li>
<p>后序遍历，递归判断每个节点是否平衡，因为先访问了左右子树，后访问根，所以需要用变量保存每个节点的深度</p>
</li>
</ol>
<h1 id="40">40 数组中只出现一次的数字</h1>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次，利用数的性质，异或运算</p>
<h1 id="41-simportant">41 和为S的连续正数序列（<strong>important</strong>）</h1>
<ul>
<li>数学公式</li>
</ul>
<h1 id="42-s">42 和为S的两个数字</h1>
<ul>
<li>
<p>排序(看题目是否是有序的) + 二分查找， 时间O(nlogn)，空间O(1)</p>
</li>
<li>
<p>hash；有序的话，前后逼近</p>
</li>
</ul>
<p>扩展：<strong>寻找和为定值的任意多个数</strong>，递归/动归</p>
<h1 id="43">43 左旋转字符串</h1>
<ul>
<li>
<p>三步翻转</p>
</li>
<li>
<p>改进三步翻转，用块交换</p>
</li>
</ul>
<h1 id="44">44 翻转单词顺序列</h1>
<ul>
<li>同 43 左旋转字符串</li>
</ul>
<h1 id="45">45 扑克牌顺子</h1>
<ul>
<li>统计个数为5，大小王个数</li>
<li>排序，逐一判断，减去大小王数目</li>
</ul>
<h1 id="46">46 孩子们的游戏(圆圈中最后剩下的数)</h1>
<ul>
<li>约瑟夫环</li>
</ul>
<p><code>f(N,M)=(f(N−1,M)+M)%N</code></p>
<p><code>f(N,M)</code>表示，<code>N</code>个人报数，每报到<code>M</code>时杀掉那个人，最终胜利者的编号<br />
<code>f(N−1,M)</code>表示，<code>N-1</code>个人报数，每报到M时杀掉那个人，最终胜利者的编号</p>
<p><img alt="" src="https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/solved_by_java/imgs/joseph.png" /></p>
<p><code>f(11, 3) = 7</code>, 可以看到<code>7</code>不断的往前面移动<code>3</code>即每杀掉一个人，其实就是把这个数组(环)向前移动了M位.</p>
<p>假设：<code>n</code>个人，最后胜利者是<code>Pn</code>位置；则经过一轮以后:变成<code>n-1</code>个人，最后胜利者位置是<code>Pn-1</code><br />
那么显然有： <code>Pn = ( Pn-1 + k ) % n</code><br />
所以有：<code>f(N,M) = ( f(N−1, M ) + M ) % N</code></p>
<h1 id="47-123n">47 求1+2+3+...+n</h1>
<ul>
<li>数学公式</li>
<li>递归</li>
</ul>
<p>考虑并发，并行流</p>
<h1 id="48">48 不用加减乘除做加法</h1>
<ul>
<li>位运算模拟</li>
</ul>
<p>异或得到想加结果（不进位）<br />
与然后左移得到进位结果</p>
<div class="hlcode"><pre><span class="mi">5</span><span class="o">:</span>  <span class="mi">0101</span>
<span class="mi">7</span><span class="o">:</span>  <span class="mi">0111</span>

  <span class="mi">0101</span>               <span class="mi">0101</span>
<span class="o">^</span> <span class="mi">0111</span>             <span class="o">&amp;</span> <span class="mi">0111</span>
<span class="o">=</span> <span class="mi">0010</span> <span class="err">（加的结果）</span>  <span class="o">=</span> <span class="mi">0101</span>  <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1010</span><span class="o">(</span><span class="err">进位情况</span><span class="o">)</span>

  <span class="mi">0010</span>               <span class="mi">0010</span>
<span class="o">^</span> <span class="mi">1010</span>             <span class="o">&amp;</span> <span class="mi">1010</span>
<span class="o">=</span> <span class="mi">1000</span> <span class="err">（加的结果）</span>  <span class="o">=</span> <span class="mi">0010</span>  <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0100</span><span class="o">(</span><span class="err">进位情况</span><span class="o">)</span>

  <span class="mi">1000</span>               <span class="mi">1000</span>
<span class="o">^</span> <span class="mi">0100</span>             <span class="o">&amp;</span> <span class="mi">0100</span>
<span class="o">=</span> <span class="mi">1100</span> <span class="err">（加的结果）</span>  <span class="o">=</span> <span class="mi">0000</span>  <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0000</span><span class="o">(</span><span class="err">进位情况</span><span class="o">)</span>

<span class="err">最后结果：</span> <span class="mi">1100</span> <span class="err">即</span> <span class="mi">12</span>
</pre></div>


<h1 id="49-important">49 把字符串转换成整数 (<strong>important</strong>)</h1>
<ul>
<li>注意最大负整数，最大正整数等特殊情况</li>
</ul>
<div class="hlcode"><pre><span class="mi">2147483647</span>
<span class="o">-</span><span class="mi">2147483648</span>
</pre></div>


<h1 id="50">50 数组中重复的数字</h1>
<ul>
<li>
<p>时间复杂度/空间复杂度考虑</p>
</li>
<li>
<p>二分法思路</p>
</li>
<li>hash辅助</li>
</ul>
<h1 id="51">51 构建乘积数组</h1>
<ul>
<li>构建左部分乘积 和 右部分乘积序列</li>
</ul>
<h1 id="52-important">52 正则表达式匹配(<strong>important</strong>)</h1>
<ul>
<li>递归 ？，.</li>
</ul>
<h1 id="53">53 表示数值的字符串</h1>
<ul>
<li>各种特殊情况</li>
</ul>
<h1 id="54">54 字符流中第一个不重复的字符</h1>
<h1 id="55">55 链表中环的入口结点</h1>
<ul>
<li>链表环的判断</li>
</ul>
<h1 id="56">56 删除链表中重复的结点</h1>
<ul>
<li>
<p>链表删除节点模拟, 注意各种特殊情况</p>
</li>
<li>
<p>使用map遍历一边获取要删的原始值，再遍历一遍真正取删除节点，构造返回</p>
</li>
<li>递归</li>
<li>加辅助头节点,一次遍历</li>
</ul>
<h1 id="57">57 二叉树的下一个结点， 中序遍历顺序的下一个结点并且返回</h1>
<h1 id="58">58 对称的二叉树</h1>
<ul>
<li>
<p>对称二叉树概念：将一棵二叉树沿着根节点对折，如果两棵子树完全重合（对称节点要么都为null，要么数据域完全相等），那么该二叉树是一个对称二叉树。</p>
</li>
<li>
<p>1 递归求解 相当于在判断root-&gt;left, root-&gt;right 两棵树 是否对折相等</p>
</li>
<li>
<p>2 非递归，用两个队列，维持root-&gt;left, root-&gt;right,节点入队列顺序不一样，判断完全</p>
</li>
</ul>
<h1 id="59">59 按之字形顺序打印二叉树</h1>
<ul>
<li>
<p>按照层次遍历，加上标记, 奇数层(偶数层)左reverse操作（reverse不可取，太low）</p>
</li>
<li>
<p>偶数层栈，奇数层栈，利用栈和二叉树的性质处理（推荐）</p>
</li>
</ul>
<h1 id="60">60 把二叉树打印成多行</h1>
<h1 id="61">61 序列化二叉树</h1>
<ul>
<li>DFS</li>
<li>BFS</li>
</ul>
<h1 id="62-k">62 二叉搜索树的第k个结点</h1>
<ul>
<li>非递归遍历(使用辅助栈和不使用辅助栈),中序遍历</li>
</ul>
<h1 id="63">63 数据流中的中位数</h1>
<p>对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。</p>
<ul>
<li>大顶堆和小顶堆。插入的时间效率是O(logn)，找中位数的时间效率是O(1)。</li>
</ul>
<h1 id="64">64 滑动窗口的最大值</h1>
<ul>
<li>
<p>利用滑动窗口的性质，双端队列处理</p>
</li>
<li>
<p>两个栈实现<code>pop-push-max</code>都是O(1)的空间换时间</p>
</li>
</ul>
<h1 id="65">65 矩阵中的路径</h1>
<ul>
<li>DFS</li>
</ul>
<h1 id="66">66 机器人的运动范围</h1>
<ul>
<li>DFS</li>
</ul>
<h1 id="67">67 剪绳子</h1>
<ul>
<li>动态规划</li>
</ul>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-04-18 18:40:38</p>
      </span>
    </div>

    
    
  </body>
</html>