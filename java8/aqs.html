<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>AQS - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java8">java8</a>&nbsp;&#187;&nbsp;AQS
    <span class="updated">Page Updated&nbsp;
      2020-20-15 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">AQS</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#abstractqueuedsynchronizer">AbstractQueuedSynchronizer</a><ul>
<li><a href="#_1">同步器</a></li>
<li><a href="#abstractqueuedsynchronizer_1">AbstractQueuedSynchronizer 相关概念</a><ul>
<li><a href="#_2">阻塞</a></li>
<li><a href="#fifoclh">FIFO队列(CLH 队列)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="abstractqueuedsynchronizer">AbstractQueuedSynchronizer</h1>
<p>参考：<a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">《The java.util.concurrent Synchronizer Framework》 JUC同步器框架（AQS框架）原文翻译</a></p>
<p><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">论文地址</a></p>
<h2 id="_1">同步器</h2>
<p>两个操作</p>
<ol>
<li><code>acquire</code>操作阻塞调用的线程，直到或除非同步状态允许其继续执行。</li>
<li><code>release</code>操作则是通过某种方式改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</li>
</ol>
<p>同步器需要支持如下：</p>
<ul>
<li>阻塞和非阻塞（例如tryLock）的同步</li>
<li>可选的超时设置，让调用者可以放弃等待</li>
<li>通过中断实现的任务取消，通常是分为两个版本，一个acquire可取消，而另一个不可以</li>
</ul>
<p>同步器的实现根据其状态是否<strong>独占</strong>而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</p>
<p>j.u.c包里还定义了Condition接口，用于支持监控形式的await/signal操作，这些操作与独占模式的Lock类有关，且Condition的实现天生就和与其关联的Lock类紧密相关</p>
<h2 id="abstractqueuedsynchronizer_1">AbstractQueuedSynchronizer 相关概念</h2>
<p>AbstractQueuedSynchronizer 抽象类的注释说明</p>
<ol>
<li>AbstractQueuedSynchronizer 提供了一个框架，用来实现blocking locks 和 一些同步器，且是基于一个FIFO队列的</li>
<li>AbstractQueuedSynchronizer 被设计为使用一个<code>single atomic {@code int} value</code>来表示状态</li>
<li>AbstractQueuedSynchronizer的子类必须去定义状态，并提供protected方法去操作状态：getState、setState以及compareAndSet</li>
<li>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态</li>
</ol>
<h3 id="_2">阻塞</h3>
<p>j.u.c包有一个LockSuport类，这个类中包含了解决这个问题的方法。方法LockSupport.park阻塞当前线程除非/直到有个LockSupport.unpark方法被调用（unpark方法被提前调用也是可以的）。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可能有“剩余的”unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地消除这个状态但并不值得这样做。在需要的时候多次调用park会更高效。</p>
<p><strong>park</strong>: n. 公园; 专用区; 园区; (英国) 庄园，庭院; v. 停(车); 泊(车); 坐下(或站着); 把…搁置，推迟(在以后的会议上讨论或处理);</p>
<h3 id="fifoclh">FIFO队列(CLH 队列)</h3>
<p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的FIFO队列，因此，框架不支持基于优先级的同步。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-05-18 10:00:44</p>
      </span>
    </div>

    
    
  </body>
</html>