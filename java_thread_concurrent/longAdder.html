<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>LongAdder - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_thread_concurrent">java_thread_concurrent</a>&nbsp;&#187;&nbsp;LongAdder
    <span class="updated">Page Updated&nbsp;
      2020-05-19 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">LongAdder</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#longadder">LongAdder</a><ul>
<li><a href="#_1">源码分析</a><ul>
<li><a href="#unsafe-int">unsafe int 操作的一些方法</a></li>
<li><a href="#cell-striped64">Cell 对象(Striped64类的静态内部类)</a></li>
<li><a href="#addlong-x">add(long x)</a><ul>
<li><a href="#longaccumulatex-null-uncontended">longAccumulate(x, null, uncontended)</a></li>
</ul>
</li>
<li><a href="#sum">sum()</a></li>
<li><a href="#longadderatomiclong">LongAdder和AtomicLong</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="longadder">LongAdder</h1>
<p>LongAdder内部将一个long分成多个cell，每个线程可以对一个cell操作，如果需要取出long数据则求和即可，这样增强了在高并发情况下的效率</p>
<div class="hlcode"><pre><span class="o">/**</span>
 <span class="o">*</span> <span class="n">One</span> <span class="n">or</span> <span class="n">more</span> <span class="n">variables</span> <span class="n">that</span> <span class="n">together</span> <span class="n">maintain</span> <span class="n">an</span> <span class="n">initially</span> <span class="n">zero</span>
 <span class="o">*</span> <span class="o">{</span><span class="nd">@code</span> <span class="kt">long</span><span class="o">}</span> <span class="n">sum</span><span class="o">.</span>  <span class="n">When</span> <span class="n">updates</span> <span class="o">(</span><span class="n">method</span> <span class="o">{</span><span class="nd">@link</span> <span class="err">#</span><span class="n">add</span><span class="o">})</span> <span class="n">are</span> <span class="n">contended</span>
 <span class="o">*</span> <span class="n">across</span> <span class="n">threads</span><span class="o">,</span> <span class="n">the</span> <span class="n">set</span> <span class="n">of</span> <span class="n">variables</span> <span class="n">may</span> <span class="n">grow</span> <span class="n">dynamically</span> <span class="n">to</span> <span class="n">reduce</span>
 <span class="o">*</span> <span class="n">contention</span><span class="o">.</span> <span class="n">Method</span> <span class="o">{</span><span class="nd">@link</span> <span class="err">#</span><span class="n">sum</span><span class="o">}</span> <span class="o">(</span><span class="n">or</span><span class="o">,</span> <span class="n">equivalently</span><span class="o">,</span> <span class="o">{</span><span class="nd">@link</span>
 <span class="o">*</span> <span class="err">#</span><span class="n">longValue</span><span class="o">})</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">current</span> <span class="n">total</span> <span class="n">combined</span> <span class="n">across</span> <span class="n">the</span>
 <span class="o">*</span> <span class="n">variables</span> <span class="n">maintaining</span> <span class="n">the</span> <span class="n">sum</span><span class="o">.</span>
 <span class="o">*</span>
</pre></div>


<ul>
<li>只能做累加，或者自增自减操作，不能做其他操作</li>
<li>用一个Cell数组来存放分段数据值大小，Cell数组中很简单只有一个value表示存放的值</li>
<li>sum方法用于返回当前计数值，返回所有Cell中value的和</li>
<li>多个线程会进行hash，对不同的Cell元素进行操作</li>
<li>内部有扩容方法，增加更多的Cell元素</li>
</ul>
<p>英语单词</p>
<ul>
<li>probe: v. 盘问; 追问; 探究; (用细长工具) 探查，查看;n.探究; 详尽调查; (不载人) 航天探测器，宇宙探测航天器; (医生用的) 探针;</li>
<li>contention: n. 争吵; 争执; 争论; (尤指争论时的) 看法，观点;</li>
</ul>
<h2 id="_1">源码分析</h2>
<h3 id="unsafe-int">unsafe int 操作的一些方法</h3>
<ul>
<li>public native int getInt(Object o, long offset);//获得给定对象偏移量上的int值</li>
<li>public native void putInt(Object o, long offset, int x);//设置给定对象偏移量上的int值</li>
<li>public native long objectFieldOffset(Field f);//获得字段在对象中的偏移量</li>
<li>public native void putIntVolatile(Object o, long offset, int x);//设置给定对象的int值，使用volatile语义</li>
<li>public native int  getIntVolatile(Object o, long offset);//获得给定对象对象的int值，使用volatile语义</li>
<li>public native void putOrderedInt(Object o, long offset, int x);//和putIntVolatile()一样，但是它要求被操作字段就是volatile类型的</li>
</ul>
<h3 id="cell-striped64">Cell 对象(<code>Striped64</code>类的静态内部类)</h3>
<ul>
<li>使用了<code>@sun.misc.Contended</code>注解(<strong>缓存行</strong>使用,解决伪共享)</li>
</ul>
<div class="hlcode"><pre><span class="cm">/**</span>
<span class="cm">    * Padded variant of AtomicLong supporting only raw accesses plus CAS.</span>
<span class="cm">    *</span>
<span class="cm">    * JVM intrinsics note: It would be possible to use a release-only</span>
<span class="cm">    * form of CAS here, if it were provided.</span>
<span class="cm">    */</span>
<span class="nd">@sun.misc.Contended</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cell</span> <span class="o">{</span>
    <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">Cell</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">cas</span><span class="o">(</span><span class="kt">long</span> <span class="n">cmp</span><span class="o">,</span> <span class="kt">long</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Unsafe mechanics</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">valueOffset</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
            <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">Cell</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
            <span class="n">valueOffset</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">ak</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li><code>Striped64</code>静态初始化</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Unsafe mechanics</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="n">UNSAFE</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">BASE</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">CELLSBUSY</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">PROBE</span><span class="o">;</span>
<span class="kd">static</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">Striped64</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="n">BASE</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
            <span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;base&quot;</span><span class="o">));</span>
        <span class="n">CELLSBUSY</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
            <span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;cellsBusy&quot;</span><span class="o">));</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">tk</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="n">PROBE</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
            <span class="o">(</span><span class="n">tk</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;threadLocalRandomProbe&quot;</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>base：为非竞争状态下的一个值</li>
<li>PROBE：一个随机的hashCode一样，每个线程有一个自己的probe，可以标示cells数组下标</li>
</ul>
<h3 id="addlong-x">add(long x)</h3>
<div class="hlcode"><pre><span class="cm">/**</span>
<span class="cm">    * Adds the given value.</span>
<span class="cm">    *</span>
<span class="cm">    * @param x the value to add</span>
<span class="cm">    */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Cell</span><span class="o">[]</span> <span class="n">as</span><span class="o">;</span> <span class="kt">long</span> <span class="n">b</span><span class="o">,</span> <span class="n">v</span><span class="o">;</span> <span class="kt">int</span> <span class="n">m</span><span class="o">;</span> <span class="n">Cell</span> <span class="n">a</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">as</span> <span class="o">=</span> <span class="n">cells</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">casBase</span><span class="o">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">base</span><span class="o">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">x</span><span class="o">))</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">uncontended</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">as</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">as</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="o">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">as</span><span class="o">[</span><span class="n">getProbe</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">m</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
            <span class="o">!(</span><span class="n">uncontended</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">cas</span><span class="o">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">v</span> <span class="o">+</span> <span class="n">x</span><span class="o">)))</span>
            <span class="n">longAccumulate</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">uncontended</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li><code>casBase</code>就是一个CAS操作(一般自旋锁这里是<code>whille(!cas){}</code>)，当有竞争的时候，CAS可能操作失败</li>
</ul>
<div class="hlcode"><pre> <span class="cm">/**</span>
<span class="cm">     * CASes the base field.</span>
<span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">casBase</span><span class="o">(</span><span class="kt">long</span> <span class="n">cmp</span><span class="o">,</span> <span class="kt">long</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">BASE</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>
</pre></div>


<ol>
<li>as == null，</li>
<li>(m = as.length - 1) &lt; 0</li>
<li>(a = as[getProbe() &amp; m]) == null</li>
<li>
<p>!(uncontended = a.cas(v = a.value, v + x))</p>
</li>
<li>
<p>if中判断1和判断2是判断cells是否为空</p>
</li>
<li>判断3是判断当前线程的cell是否是null</li>
<li>判断4是当前线程进行cas操作</li>
<li>最后是<code>longAccumulate(x, null, uncontended);</code></li>
</ol>
<h4 id="longaccumulatex-null-uncontended">longAccumulate(x, null, uncontended)</h4>
<p>如果<code>Cell[]</code>数组未初始化，会调用父类的longAccumelate去初始化<code>Cell[]</code>，如果<code>Cell[]</code>已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对<code>Cell[]</code>扩容了。</p>
<h3 id="sum">sum()</h3>
<p>base + <code>cells</code>数组中各内容值</p>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kt">long</span> <span class="nf">sum</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Cell</span><span class="o">[]</span> <span class="n">as</span> <span class="o">=</span> <span class="n">cells</span><span class="o">;</span> <span class="n">Cell</span> <span class="n">a</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">as</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">as</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">a</span> <span class="o">=</span> <span class="n">as</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<h3 id="longadderatomiclong">LongAdder和AtomicLong</h3>
<p><a href="http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/" target="_blank">性能对比</a></p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-06-17 09:55:30</p>
      </span>
    </div>

    
    
  </body>
</html>