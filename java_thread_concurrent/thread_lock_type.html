<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Java中的各种锁概念 - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_thread_concurrent">java_thread_concurrent</a>&nbsp;&#187;&nbsp;Java中的各种锁概念
    <span class="updated">Page Updated&nbsp;
      2019-03-15 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Java中的各种锁概念</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">常见的各种锁</a><ul>
<li><a href="#_2">线程同步概念</a></li>
<li><a href="#cas">CAS 原子操作</a></li>
<li><a href="#_3">乐观锁&amp;悲观锁</a><ul>
<li><a href="#_4">乐观锁</a></li>
<li><a href="#_5">悲观锁</a></li>
</ul>
</li>
<li><a href="#_6">自旋锁</a><ul>
<li><a href="#_7">自旋锁存在的意义与使用场景</a></li>
<li><a href="#atomicreference">AtomicReference实现一个公平的自旋锁</a></li>
<li><a href="#cpu">得不到锁的线程让出CPU</a></li>
<li><a href="#sleep">得不到锁，线程sleep, 睡眠时间不确定？</a></li>
<li><a href="#locksupportpark-unpark">LockSupport.park() &amp; unpark()</a></li>
<li><a href="#_8">适应性自旋锁</a></li>
</ul>
</li>
<li><a href="#reentrantlock">ReentrantLock (可重入锁，递归锁)</a><ul>
<li><a href="#_9">公平锁</a></li>
<li><a href="#_10">非公平锁</a><ul>
<li><a href="#synchronized-reentrantlock">对比synchronized, ReentrantLock的一些高级功能</a></li>
</ul>
</li>
<li><a href="#_11">锁申请等待限时实际例子</a></li>
</ul>
</li>
<li><a href="#_12">读写锁</a><ul>
<li><a href="#_13">伪代码</a></li>
<li><a href="#_14">实际例子</a></li>
</ul>
</li>
<li><a href="#_15">分布式锁</a><ul>
<li><a href="#_16">什么是分布式锁</a></li>
<li><a href="#_17">分布式锁的实现方式</a></li>
</ul>
</li>
<li><a href="#_18">共享锁(读锁) 和 排它锁(写锁)</a><ul>
<li><a href="#exclusive-locks">Exclusive locks</a></li>
<li><a href="#shared-locks">Shared locks</a></li>
</ul>
</li>
<li><a href="#biased-locking">偏向锁（Biased Locking）</a></li>
<li><a href="#_19">轻量级锁</a></li>
<li><a href="#_20">重量级锁（内核控制）</a><ul>
<li><a href="#_21">为什么说重量级锁开销大呢？</a></li>
</ul>
</li>
<li><a href="#aqs">AQS</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="_1">常见的各种锁</h1>
<h2 id="_2">线程同步概念</h2>
<p>多线程对共享资源的操作按照一定次序，避免出现不可预知的结局</p>
<p><a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)">Synchronization_(computer_science)</a></p>
<h2 id="cas">CAS 原子操作</h2>
<p>既然用锁或<code>synchronized</code>关键字可以实现原子操作，那么为什么还要用<code>CAS</code>呢，因为加锁或使用<code>synchronized</code>关键字带来的性能损耗较大，而用<code>CAS</code>可以实现乐观锁，它实际上是直接利用了<code>CPU</code>层面的指令(由现代CPU在硬件级实现的原子指令，允许进行无阻塞，多线程的数据操作同时兼顾了安全性以及效率)，所以性能稍高。</p>
<p><code>synchronized</code>关键字会让没有得到锁资源的线程进入<code>BLOCKED</code>状态，而后在争夺到锁资源后恢复为<code>RUNNABLE</code>状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p>
<ul>
<li><code>synchronized</code>属于<strong>悲观锁</strong>，悲观地认为程序中的并发情况严重，所以严防死守</li>
<li><code>CAS</code>属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新</li>
</ul>
<h2 id="_3">乐观锁&amp;悲观锁</h2>
<h3 id="_4">乐观锁</h3>
<p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以<strong>不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。eg: CAS</p>
<h3 id="_5">悲观锁</h3>
<p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候<strong>都会上锁</strong>，这样别人想读写这个数据就会Block直到拿到锁。Java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试CAS乐观锁去获取锁，获取不到，才会转换为悲观锁，如偏向锁(RetreenLock)。</p>
<h2 id="_6">自旋锁</h2>
<p><a href="https://en.wikipedia.org/wiki/Spinlock" target="_blank">Spinlock WikiPedia</a></p>
<p>自旋锁是采用让当前线程不停地的在循环体内执行实现的，只有当循环的条件被其它线程改变时，才能进入临界区；否则一直自旋</p>
<h3 id="_7">自旋锁存在的意义与使用场景</h3>
<p>阻塞与唤醒线程需要操作系统切换CPU状态，需要消耗一定时间；自旋只是当前线程自己循环，没有线程状态的改变，稍快</p>
<h3 id="atomicreference">AtomicReference实现一个公平的自旋锁</h3>
<div class="hlcode"><pre><span class="cm">/**</span>
<span class="cm"> * 使用了CAS原子操作，lock函数将owner设置为当前线程，并且预测原来的值为空。unlock函数将owner设置为null，并且预测值为当前线程</span>
<span class="cm"> *</span>
<span class="cm"> * 该例子为非公平锁，获得锁的先后顺序，不会按照进入lock的先后顺序进行</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kd">class</span> <span class="nc">SpinLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="n">sign</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">(){</span>
        <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="c1">// 如果是null，设置为current；设置失败，就一直自旋，直到能设置成功</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">sign</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">current</span><span class="o">)){</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span> <span class="o">(){</span>
        <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="c1">// 如果是current,设置为null</span>
        <span class="n">sign</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">static</span> <span class="n">SpinLock</span> <span class="n">spinLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpinLock</span><span class="o">();</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addSync</span><span class="o">(){</span>
        <span class="n">spinLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">spinLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="n">threadList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">n</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span> <span class="o">()-&gt;</span> <span class="n">Solution</span><span class="o">.</span><span class="na">add</span><span class="o">(),</span> <span class="s">&quot;add&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="n">threadList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">threadList</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">());</span>
        <span class="n">threadList</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">t</span><span class="o">-&gt;{</span>
            <span class="k">try</span><span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Solution</span><span class="o">.</span><span class="na">cnt</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<p>由于自旋锁只是将当前线程不停地执行循环体，<strong>不进行线程状态的改变</strong>，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，<strong>占用CPU时间</strong>。如果线程竞争不激烈，并且保持锁的时间短，则适合使用自旋锁。</p>
<p>In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting. Once acquired, spinlocks will usually be held until they are explicitly released, although in some implementations they may be automatically released if the thread being waited on (the one which holds the lock) blocks, or "goes to sleep".</p>
<p>Because they avoid overhead from operating system process rescheduling or context switching, spinlocks are efficient if threads are likely to be blocked for only short periods. For this reason, operating-system kernels often use spinlocks. However, spinlocks become wasteful if held for longer durations, as they may prevent other threads from running and require rescheduling. The longer a thread holds a lock, the greater the risk that the thread will be interrupted by the OS scheduler while holding the lock. If this happens, other threads will be left "spinning" (repeatedly trying to acquire the lock), while the thread holding the lock is not making progress towards releasing it. The result is an indefinite postponement until the thread holding the lock can finish and release it. This is especially true on a single-processor system, where each waiting thread of the same priority is likely to waste its quantum (allocated time where a thread can run) spinning until the thread that holds the lock is finally finished.</p>
<ul>
<li>线程状态不变，不导致上线文切换，适合短时间自旋</li>
<li>长时间会耗CPU，影响其它线程的调度</li>
</ul>
<h3 id="cpu">得不到锁的线程让出CPU</h3>
<p>竞争锁失败的线程让出CPU(可以使用yield()让出CPU,这是CPU控制的)，可能出现每次都是某一个线程让出CPU，得不到执行</p>
<div class="hlcode"><pre><span class="kd">class</span> <span class="nc">SpinLock</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">sign</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;(</span><span class="mi">0</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">lock</span><span class="o">(){</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">sign</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)){</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(){</span>
        <span class="c1">// 解锁就是设置为</span>
        <span class="n">sign</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3 id="sleep">得不到锁，线程sleep, 睡眠时间不确定？</h3>
<div class="hlcode"><pre><span class="kd">class</span> <span class="nc">SpinLock</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">sign</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;(</span><span class="mi">0</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">lock</span><span class="o">(){</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">sign</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">{</span>
                <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
            <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>

            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(){</span>
        <span class="c1">// 解锁就是设置为</span>
        <span class="n">sign</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3 id="locksupportpark-unpark">LockSupport.park() &amp; unpark()</h3>
<div class="hlcode"><pre><span class="kd">class</span> <span class="nc">SpinLock</span><span class="o">{</span>

    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="n">parkQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">private</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="n">sign</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;(</span><span class="kc">null</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">lock</span><span class="o">(){</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">sign</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())){</span>
            <span class="n">park</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(){</span>
        <span class="n">sign</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 同时唤醒其它线程</span>
        <span class="n">lockNotify</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">park</span><span class="o">(){</span>
<span class="c1">//        System.out.println(&quot;park thread:&quot; + Thread.currentThread().getName());</span>
        <span class="n">parkQueue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
        <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">lockNotify</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parkQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 先进先出</span>
        <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">parkQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
<span class="c1">//        System.out.println(&quot;unpark thread:&quot; + t.getName());</span>
        <span class="n">unpark</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">unpark</span><span class="o">(</span><span class="n">Thread</span> <span class="n">t</span><span class="o">){</span>
        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<h3 id="_8">适应性自旋锁</h3>
<p>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。</p>
<p>自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化:</p>
<ul>
<li>
<p>如果平均负载小于CPUs则一直自旋</p>
</li>
<li>
<p>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</p>
</li>
<li>
<p>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞</p>
</li>
<li>
<p>如果CPU处于节电模式则停止自旋</p>
</li>
<li>
<p>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</p>
</li>
<li>
<p>自旋时会适当放弃线程优先级之间的差异</p>
</li>
</ul>
<h2 id="reentrantlock">ReentrantLock (可重入锁，递归锁)</h2>
<ul>
<li>什么是可重入？</li>
</ul>
<p>同一个线程可以反复获取锁多次，然后需要释放多次</p>
<p>同一个线程在外层函数获得锁之后，内层递归函数仍能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，即：<strong>线程可以进入任何一个它已经拥有的锁所同步的代码块</strong>，防止死锁</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Phone</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">sendSMS</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span> <span class="s">&quot;\t invoked sendSMS()&quot;</span><span class="o">);</span>
        <span class="n">sendEmail</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">sendEmail</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span> <span class="s">&quot;\t #####invoked sendEmail()&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// ==============================================================</span>
    <span class="cm">/**</span>
<span class="cm">     *  可重入锁底层原理：公平锁和非公平锁(默认)</span>
<span class="cm">     *  公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。</span>
<span class="cm">     *  非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</span>
<span class="cm">     *            在高并发的情况下，有可能会造成优先级反转或者饥饿现象。优点：吞吐量比公平锁大。</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">getd</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">getd</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span> <span class="s">&quot;\t invoked getd()&quot;</span><span class="o">);</span>
            <span class="n">setd</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setd</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 这里注释掉会出现：java.lang.IllegalMonitorStateException，所以锁一定要配对</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span> <span class="s">&quot;\t ### invoked setd()&quot;</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * @author doinb</span>
<span class="cm"> * 可重入锁（也叫做递归锁） 作用：避免死锁</span>
<span class="cm"> *</span>
<span class="cm"> * 指的是同一线程外层函数获得锁之后，内层函数仍然能获取该锁代码，</span>
<span class="cm"> * 在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</span>
<span class="cm"> *</span>
<span class="cm"> * 也就是说，线程可以进入任何一个它已经拥有的锁所同步的代码块。</span>
<span class="cm"> *</span>
<span class="cm"> *  case 1 Synchronized就是一个典型的可重入锁</span>
<span class="cm"> * t1    invoked sendSMS()          t1线程在外层方法获取锁的时候</span>
<span class="cm"> * t1    #####invoked sendEmail()   t1在进入内层方法会自动获取锁</span>
<span class="cm"> * t2    invoked sendSMS()</span>
<span class="cm"> * t2    #####invoked sendEmail()</span>
<span class="cm"> *</span>
<span class="cm"> *  case 2 ReentrantLock也是一个典型的可重入锁</span>
<span class="cm"> * t3    invoked getd()</span>
<span class="cm"> * t3    ### invoked setd()</span>
<span class="cm"> * t4    invoked getd()</span>
<span class="cm"> * t4    ### invoked setd()</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">Phone</span> <span class="n">phone</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Phone</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">phone</span><span class="o">.</span><span class="na">sendSMS</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">},</span> <span class="s">&quot;t1&quot;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">phone</span><span class="o">.</span><span class="na">sendSMS</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">},</span> <span class="s">&quot;t2&quot;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">// 暂停一会</span>
        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;### lock的启动方式，因为实现了Runnable接口 ###&quot;</span><span class="o">);</span>

        <span class="c1">// lock的启动方式，因为实现了Runnable接口</span>
        <span class="n">Thread</span> <span class="n">t3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">phone</span><span class="o">,</span> <span class="s">&quot;t3&quot;</span><span class="o">);</span>
        <span class="n">Thread</span> <span class="n">t4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">phone</span><span class="o">,</span> <span class="s">&quot;t4&quot;</span><span class="o">);</span>
        <span class="n">t3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t4</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<h3 id="_9">公平锁</h3>
<p>表示线程获取锁的顺序是按照线程申请锁的顺序来分配的，即<code>FIFO</code>, 队列结构</p>
<div class="hlcode"><pre> <span class="cm">/**</span>
<span class="cm">    * Sync object for fair locks</span>
<span class="cm">    */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3000897897090466540L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">        * Fair version of tryAcquire.  Don&#39;t grant access unless</span>
<span class="cm">        * recursive call or no waiters or is first.</span>
<span class="cm">        */</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
                <span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>
<p>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其它线程永远无法获取到锁，造成<code>饥饿</code>现象。</p>
</li>
<li>
<p>公平锁为了保证时间上的绝对顺序，需要<strong>频繁的上下文切换</strong>；而非公平锁会降低了一定的上下文切换，降低性能开销。</p>
</li>
</ul>
<h3 id="_10">非公平锁</h3>
<p>就是一种获取锁的<code>抢占</code>机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果也就是不公平。尝试抢占失败，就再采用公平锁的那种方式，<code>吞吐量</code>大于公平锁</p>
<h4 id="synchronized-reentrantlock">对比<code>synchronized</code>, <code>ReentrantLock</code>的一些高级功能</h4>
<ul>
<li>等待可中断</li>
</ul>
<p>持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。</p>
<ul>
<li><code>ReentrantLock</code>创建公平锁</li>
</ul>
<p><code>ReentrantLock</code>默认的构造函数是创建的<code>非公平锁</code>，可以通过参数<code>true</code>设为<code>公平锁</code>，但公平锁表现的性能不是很好。</p>
<p><code>synchronized</code>是非公平锁（因为<code>synchronized</code>是不公平竞争，后来的线程可能先得到锁，进而可能导致先到的线程持续饥饿，非公平竞争在很大程度上提升了<code>synchronized</code>吞吐率），可以重入</p>
<ul>
<li>锁绑定多个条件</li>
</ul>
<p>一个<code>ReentrantLock</code>对象可以同时绑定对个对象。</p>
<h3 id="_11">锁申请等待限时实际例子</h3>
<p>申请锁，一定时间内获取不到，选择放弃</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Condition</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm"> * @Author mubi</span>
<span class="cm"> * @Date 2019/3/15 7:24 AM</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>
        <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
        <span class="n">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>

        <span class="n">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;A start&quot;</span><span class="o">);</span>
                    <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
                    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B get lock start&quot;</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; tryLock error&quot;</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;B Exception&quot;</span><span class="o">);</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span> <span class="o">((</span><span class="n">ReentrantLock</span><span class="o">)</span> <span class="n">lock</span><span class="o">).</span><span class="na">isHeldByCurrentThread</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="c1">// 让A 先于B 运行</span>
        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="n">threadA</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;main end&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* output</span>
<span class="cm">A start</span>
<span class="cm">Thread-1 tryLock error</span>
<span class="cm">main end</span>
<span class="cm">*/</span>
</pre></div>


<h2 id="_12">读写锁</h2>
<p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。</p>
<p>一次只有一个线程可以占有<code>写模式</code>的读写锁, 但是可以有多个线程同时占有<code>读模式</code>的读写锁.</p>
<h3 id="_13">伪代码</h3>
<div class="hlcode"><pre><span class="n">count_mutex</span> <span class="o">=</span> <span class="n">mutex_init</span><span class="p">();</span>
<span class="n">write_mutex</span> <span class="o">=</span> <span class="n">mutex_init</span><span class="p">();</span>
<span class="n">read_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">read_lock</span><span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="n">count_mutex</span><span class="p">);</span>
    <span class="n">read_count</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 第一个读者开始读时获得写锁</span>
        <span class="n">lock</span><span class="p">(</span><span class="n">write_mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">(</span><span class="n">count_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">read_unlock</span><span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="n">count_mutex</span><span class="p">);</span>
    <span class="n">read_count</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//  最后一个读者离开时释放写锁</span>
        <span class="n">unlock</span><span class="p">(</span><span class="n">write_mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">(</span><span class="n">count_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">write_lock</span><span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="n">write_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">write_unlock</span><span class="p">{</span>
    <span class="n">unlock</span><span class="p">(</span><span class="n">write_mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>参考：<a href="https://www.cnblogs.com/xiehongfeng100/p/4782135.html" target="_blank">https://www.cnblogs.com/xiehongfeng100/p/4782135.html</a></p>
<h3 id="_14">实际例子</h3>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">java.text.SimpleDateFormat</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Date</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ArrayBlockingQueue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ThreadPoolExecutor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantReadWriteLock</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm"> * @Author mubi</span>
<span class="cm"> * @Date 2019/3/17 7:56 PM</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ReentrantReadWriteLock</span> <span class="n">rwLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantReadWriteLock</span><span class="o">();</span>
    <span class="n">Lock</span> <span class="n">readLock</span> <span class="o">=</span> <span class="n">rwLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span>
    <span class="n">Lock</span> <span class="n">writeLock</span> <span class="o">=</span> <span class="n">rwLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kt">double</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">read</span><span class="o">(){</span>
        <span class="n">readLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;读数据：&quot;</span> <span class="o">+</span> <span class="n">data</span>
                    <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span>  <span class="k">new</span> <span class="n">SimpleDateFormat</span><span class="o">(</span><span class="s">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="o">).</span><span class="na">format</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">()));</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
            <span class="n">readLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(){</span>
        <span class="n">writeLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">10</span><span class="o">));</span>
            <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextDouble</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; ........写入数据: &quot;</span> <span class="o">+</span> <span class="n">data</span>
                    <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span>  <span class="k">new</span> <span class="n">SimpleDateFormat</span><span class="o">(</span><span class="s">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="o">).</span><span class="na">format</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">()));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">writeLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">Main</span> <span class="n">main</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Main</span><span class="o">();</span>
        <span class="n">ThreadPoolExecutor</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span>
                <span class="mi">10</span><span class="o">,</span>
                <span class="mi">200</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                <span class="k">new</span> <span class="n">ArrayBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;(</span><span class="mi">5</span><span class="o">),</span>
                <span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">.</span><span class="na">DiscardOldestPolicy</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">pool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()-&gt;</span> <span class="n">main</span><span class="o">.</span><span class="na">read</span><span class="o">());</span>
            <span class="n">pool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()-&gt;</span> <span class="n">main</span><span class="o">.</span><span class="na">write</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="n">pool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<ul>
<li>output</li>
</ul>
<p><strong>某个时刻可以有多个读，但只能有一个写，写的时候不能读，读的时候不能写</strong></p>
<div class="hlcode"><pre><span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">1</span><span class="err">读数据：</span><span class="mf">0.0</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">53</span><span class="o">:</span><span class="mi">43</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">3</span><span class="err">读数据：</span><span class="mf">0.0</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">53</span><span class="o">:</span><span class="mi">43</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">1</span> <span class="o">........</span><span class="err">写入数据</span><span class="o">:</span> <span class="mf">0.14383955312719565</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">53</span><span class="o">:</span><span class="mi">48</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">2</span> <span class="o">........</span><span class="err">写入数据</span><span class="o">:</span> <span class="mf">0.36604507657651075</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">53</span><span class="o">:</span><span class="mi">57</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">4</span> <span class="o">........</span><span class="err">写入数据</span><span class="o">:</span> <span class="mf">0.24110141917904238</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">03</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">4</span> <span class="o">........</span><span class="err">写入数据</span><span class="o">:</span> <span class="mf">0.6412197875946629</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">08</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">6</span><span class="err">读数据：</span><span class="mf">0.6412197875946629</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">09</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">5</span><span class="err">读数据：</span><span class="mf">0.6412197875946629</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">09</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">7</span> <span class="o">........</span><span class="err">写入数据</span><span class="o">:</span> <span class="mf">0.3115143131633106</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">12</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">8</span><span class="err">读数据：</span><span class="mf">0.3115143131633106</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">13</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">9</span> <span class="o">........</span><span class="err">写入数据</span><span class="o">:</span> <span class="mf">0.08244939010952534</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">21</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">3</span><span class="err">读数据：</span><span class="mf">0.08244939010952534</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">22</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">10</span><span class="err">读数据：</span><span class="mf">0.08244939010952534</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">22</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">1</span> <span class="o">........</span><span class="err">写入数据</span><span class="o">:</span> <span class="mf">0.7060105583988802</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">31</span>
<span class="n">pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">2</span><span class="err">读数据：</span><span class="mf">0.7060105583988802</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">17</span> <span class="mi">19</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">32</span>
</pre></div>


<h2 id="_15">分布式锁</h2>
<p>很多时候我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，通过 Java 提供的并发 API 我们可以解决，分布式环境下</p>
<ol>
<li>分布式与单机情况下最大的不同在于其不是多线程而是<strong>多进程</strong></li>
<li><code>多线程</code>由于可以<code>共享堆内存</code>，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将<code>标记</code>存储在一个<code>所有进程</code>都能看到的地方</li>
</ol>
<p><a target='_blank' href='https://www.cnblogs.com/seesun2012/p/9214653.html'>参考</a></p>
<h3 id="_16">什么是分布式锁</h3>
<p>在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问</p>
<ul>
<li>
<p>排它性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取</p>
</li>
<li>
<p>避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）</p>
</li>
<li>
<p>高可用：获取或释放锁的机制必须高可用且性能佳</p>
</li>
</ul>
<h3 id="_17">分布式锁的实现方式</h3>
<ol>
<li>
<p>基于数据库实现</p>
</li>
<li>
<p>基于缓存</p>
</li>
<li>
<p>基于ZooKeeper实现</p>
</li>
</ol>
<h2 id="_18">共享锁(读锁) 和 排它锁(写锁)</h2>
<h3 id="exclusive-locks">Exclusive locks</h3>
<p>Exclusive locks protect updates to file resources, both recoverable and non-recoverable. They can be owned by only one transaction at a time. Any transaction that requires an exclusive lock must wait if another task currently owns an exclusive lock or a shared lock against the requested resource.</p>
<p>独占锁保护文件资源(包括可恢复和不可恢复的文件资源)的更新。它们一次只能由一个事务拥有。如果另一个任务当前拥有对所请求资源的独占锁或共享锁，则任何需要对该资源申请独占锁的事务都必须等待。</p>
<h3 id="shared-locks">Shared locks</h3>
<p>Shared locks support read integrity. They ensure that a record is not in the process of being updated during a read-only request. Shared locks can also be used to prevent updates of a record between the time that a record is read and the next syncpoint.</p>
<p>共享锁支持读完整性。它们确保在只读请求期间不会更新记录。共享锁还可用于防止在读取记录和下一个同步点之间进行更新操作。</p>
<p>A shared lock on a resource can be owned by several tasks at the same time. However, although several tasks can own shared locks, there are some circumstances in which tasks can be forced to wait for a lock:</p>
<p>资源上的共享锁可以同时由多个任务拥有。 但是，尽管有几个任务可以拥有共享锁，但在某些情况下可以强制任务等待锁：</p>
<ul>
<li>A request for a shared lock must wait if another task currently owns an exclusive lock on the resource.</li>
<li>A request for an exclusive lock must wait if other tasks currently own shared locks on this resource.</li>
<li>
<p>A new request for a shared lock must wait if another task is waiting for an exclusive lock on a resource that already has a shared lock.</p>
</li>
<li>
<p>如果另一个任务当前拥有资源上的独占锁，则对共享锁的请求必须等待。</p>
</li>
<li>如果其他任务当前拥有此资源上的共享锁，则必须等待对独占锁的请求。</li>
<li>如果另一个任务正在等待已经具有共享锁的资源的独占锁，则对共享锁的新请求必须等待。</li>
</ul>
<h2 id="biased-locking">偏向锁（Biased Locking）</h2>
<p>锁的实现机制与Java对象头息息相关，<strong>锁的所有信息，都记录在Java的对象头中</strong>。</p>
<p>大多数情况下，锁不仅<strong>不存在多线程竞争</strong>，而且<strong>总是由同一线程多次获得</strong>，这个线程就是锁的偏向线程。</p>
<p>为了让线程获得锁的代价更低而引入偏向锁。那么只需要<strong>在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁，直到竞争发生才释放锁</strong>。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致则直接进入同步/退出同步,也<strong>无需每次加锁/解锁</strong>都去CAS更新对象头；如果不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候需要锁膨胀为轻量级锁，才能保证线程间公平竞争锁。</p>
<h2 id="_19">轻量级锁</h2>
<p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争的时候，偏向锁就会升级为轻量级锁。（轻量级锁是用户态的，通常会自旋占用CPU）</p>
<p>轻量锁与偏向锁不同的是：</p>
<ol>
<li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li>
<li>每次进入/退出同步块都需要CAS更新对象头</li>
<li>争夺轻量级锁失败时，自旋尝试抢占锁</li>
</ol>
<p>可以看到轻量锁适合在竞争情况下使用，其自旋锁可以保证响应速度快，但自旋操作会占用CPU，所以一些计算时间长的操作不适合使用轻量级锁。</p>
<p>当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。</p>
<h2 id="_20">重量级锁（内核控制）</h2>
<p>当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。</p>
<p>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖<strong>操作系统的MutexLock(互斥锁)</strong>来实现的，所以重量级锁也被成为互斥锁。（带wait队列，把没有获取锁的线程放队列，冷冻着，不占用CPU；内核让执行了，用户态/内核态切换，然后执行）</p>
<h3 id="_21">为什么说重量级锁开销大呢？</h3>
<p>主要是：当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被<strong>阻塞的线程不会消耗cpu</strong>。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这需要把线程从<strong>用户态</strong>转换到<strong>内核态</strong>，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。这就是说为什么重量级线程开销很大的。</p>
<h2 id="aqs">AQS</h2>
<p><code>AbstractQuenedSynchronizer</code>抽象的队列式同步器,是除了java自带的<code>synchronized</code>关键字之外的锁机制</p>
<div class="hlcode"><pre><span class="o">/**</span>
 <span class="o">*</span> <span class="n">Provides</span> <span class="n">a</span> <span class="n">framework</span> <span class="k">for</span> <span class="n">implementing</span> <span class="n">blocking</span> <span class="n">locks</span> <span class="n">and</span> <span class="n">related</span>
 <span class="o">*</span> <span class="n">synchronizers</span> <span class="o">(</span><span class="n">semaphores</span><span class="o">,</span> <span class="n">events</span><span class="o">,</span> <span class="n">etc</span><span class="o">)</span> <span class="n">that</span> <span class="n">rely</span> <span class="n">on</span>
 <span class="o">*</span> <span class="n">first</span><span class="o">-</span><span class="n">in</span><span class="o">-</span><span class="n">first</span><span class="o">-</span><span class="n">out</span> <span class="o">(</span><span class="n">FIFO</span><span class="o">)</span> <span class="n">wait</span> <span class="n">queues</span><span class="o">.</span>  <span class="n">This</span> <span class="kd">class</span> <span class="nc">is</span> <span class="n">designed</span> <span class="n">to</span>
 <span class="o">*</span> <span class="n">be</span> <span class="n">a</span> <span class="n">useful</span> <span class="n">basis</span> <span class="k">for</span> <span class="n">most</span> <span class="n">kinds</span> <span class="n">of</span> <span class="n">synchronizers</span> <span class="n">that</span> <span class="n">rely</span> <span class="n">on</span> <span class="n">a</span>
 <span class="o">*</span> <span class="n">single</span> <span class="n">atomic</span> <span class="o">{</span><span class="nd">@code</span> <span class="kt">int</span><span class="o">}</span> <span class="n">value</span> <span class="n">to</span> <span class="n">represent</span> <span class="n">state</span><span class="o">.</span> <span class="n">Subclasses</span>
 <span class="o">*</span> <span class="n">must</span> <span class="n">define</span> <span class="n">the</span> <span class="kd">protected</span> <span class="n">methods</span> <span class="n">that</span> <span class="n">change</span> <span class="k">this</span> <span class="n">state</span><span class="o">,</span> <span class="n">and</span> <span class="n">which</span>
 <span class="o">*</span> <span class="n">define</span> <span class="n">what</span> <span class="n">that</span> <span class="n">state</span> <span class="n">means</span> <span class="n">in</span> <span class="n">terms</span> <span class="n">of</span> <span class="k">this</span> <span class="n">object</span> <span class="n">being</span> <span class="n">acquired</span>
 <span class="o">*</span> <span class="n">or</span> <span class="n">released</span><span class="o">.</span>  <span class="n">Given</span> <span class="n">these</span><span class="o">,</span> <span class="n">the</span> <span class="n">other</span> <span class="n">methods</span> <span class="n">in</span> <span class="k">this</span> <span class="kd">class</span> <span class="nc">carry</span>
 <span class="o">*</span> <span class="n">out</span> <span class="n">all</span> <span class="n">queuing</span> <span class="n">and</span> <span class="n">blocking</span> <span class="n">mechanics</span><span class="o">.</span> <span class="n">Subclasses</span> <span class="n">can</span> <span class="n">maintain</span>
 <span class="o">*</span> <span class="n">other</span> <span class="n">state</span> <span class="n">fields</span><span class="o">,</span> <span class="n">but</span> <span class="n">only</span> <span class="n">the</span> <span class="n">atomically</span> <span class="n">updated</span> <span class="o">{</span><span class="nd">@code</span> <span class="kt">int</span><span class="o">}</span>
 <span class="o">*</span> <span class="n">value</span> <span class="n">manipulated</span> <span class="n">using</span> <span class="n">methods</span> <span class="o">{</span><span class="nd">@link</span> <span class="err">#</span><span class="n">getState</span><span class="o">},</span> <span class="o">{</span><span class="nd">@link</span>
 <span class="o">*</span> <span class="err">#</span><span class="n">setState</span><span class="o">}</span> <span class="n">and</span> <span class="o">{</span><span class="nd">@link</span> <span class="err">#</span><span class="n">compareAndSetState</span><span class="o">}</span> <span class="n">is</span> <span class="n">tracked</span> <span class="n">with</span> <span class="n">respect</span>
 <span class="o">*</span> <span class="n">to</span> <span class="n">synchronization</span><span class="o">.</span>
 <span class="o">*</span>
</pre></div>


<p>内部通过一个int类型的成员变量state来控制同步状态(对同步状态执行CAS操作)</p>
<p>当state=0时，则说明没有任何线程占有共享资源的锁，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待</p>
<p>Node结点是对每一个访问同步代码的线程的封装,包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等</p>
<div class="hlcode"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="c1">//共享模式</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">SHARED</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
    <span class="c1">//独占模式</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">EXCLUSIVE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">//标识线程已处于结束状态</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span> <span class="o">=</span>  <span class="mi">1</span><span class="o">;</span>
    <span class="c1">//等待被唤醒状态</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SIGNAL</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="c1">//条件状态，</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CONDITION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>
    <span class="c1">//在共享模式中使用表示获得的同步状态会被传播</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PROPAGATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">;</span>

    <span class="c1">//等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span>
    <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">waitStatus</span><span class="o">;</span>

    <span class="c1">//同步队列中前驱结点</span>
    <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">prev</span><span class="o">;</span>

    <span class="c1">//同步队列中后继结点</span>
    <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="c1">//请求锁的线程</span>
    <span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">thread</span><span class="o">;</span>

    <span class="c1">//等待队列中的后继结点，这个与Condition有关，稍后会分析</span>
    <span class="n">Node</span> <span class="n">nextWaiter</span><span class="o">;</span>

    <span class="c1">//判断是否为共享模式</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isShared</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nextWaiter</span> <span class="o">==</span> <span class="n">SHARED</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//获取前驱结点</span>
    <span class="kd">final</span> <span class="n">Node</span> <span class="nf">predecessor</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NullPointerException</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//.....</span>
<span class="o">}</span>
</pre></div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-06-16 20:57:45</p>
      </span>
    </div>

    
    
  </body>
</html>