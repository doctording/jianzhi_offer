<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/sword_at_offer/static/css/tango.css">
    <link rel="shortcut icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/sword_at_offer/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>AQS - 剑指Offer</title>
    <meta name="keywords" content="algorithm，python"/>
    <meta name="description" content="for python and algorithm"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/sword_at_offer/">Home</a>&nbsp;&#187;&nbsp;<a href="/sword_at_offer/#java_thread_concurrent">java_thread_concurrent</a>&nbsp;&#187;&nbsp;AQS
    <span class="updated">Page Updated&nbsp;
      2020-20-15 00:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">AQS</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#abstractqueuedsynchronizer">AbstractQueuedSynchronizer</a><ul>
<li><a href="#_1">同步器</a></li>
<li><a href="#abstractqueuedsynchronizer_1">AbstractQueuedSynchronizer 相关概念</a><ul>
<li><a href="#_2">阻塞</a></li>
<li><a href="#fifoclh">FIFO队列(CLH 队列，双向链表)</a></li>
<li><a href="#abstractqueuedsynchronizerlock">自己实现AbstractQueuedSynchronizer抽象类和Lock接口</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="abstractqueuedsynchronizer">AbstractQueuedSynchronizer</h1>
<ul>
<li>锁的实现框架</li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">《The java.util.concurrent Synchronizer Framework》 JUC同步器框架（AQS框架）原文翻译</a></p>
<p><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">论文地址</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">docs api</a></p>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState(), setState(int) and compareAndSetState(int, int) is tracked with respect to synchronization.</p>
<h2 id="_1">同步器</h2>
<p>两个操作</p>
<ol>
<li><code>acquire</code>操作阻塞调用的线程，直到或除非同步状态允许其继续执行。</li>
<li><code>release</code>操作则是通过某种方式改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</li>
</ol>
<p>同步器需要支持如下：</p>
<ul>
<li>阻塞和非阻塞（例如tryLock）的同步</li>
<li>可选的超时设置，让调用者可以放弃等待</li>
<li>通过中断实现的任务取消，通常是分为两个版本，一个acquire可取消，而另一个不可以</li>
</ul>
<p>同步器的实现根据其状态是否<strong>独占</strong>而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</p>
<p>j.u.c包里还定义了Condition接口，用于支持监控形式的await/signal操作，这些操作与独占模式的Lock类有关，且Condition的实现天生就和与其关联的Lock类紧密相关</p>
<ul>
<li>AbstractQueuedSynchronizer 的变量： 有CLH队列的头部，尾部，以及同步器状态的int变量</li>
</ul>
<div class="hlcode"><pre> <span class="cm">/**</span>
<span class="cm">     * Head of the wait queue, lazily initialized.  Except for</span>
<span class="cm">     * initialization, it is modified only via method setHead.  Note:</span>
<span class="cm">     * If head exists, its waitStatus is guaranteed not to be</span>
<span class="cm">     * CANCELLED.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Tail of the wait queue, lazily initialized.  Modified only via</span>
<span class="cm">     * method enq to add new wait node.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">tail</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">     * The synchronization state.</span>
<span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
</pre></div>


<h2 id="abstractqueuedsynchronizer_1">AbstractQueuedSynchronizer 相关概念</h2>
<p>AbstractQueuedSynchronizer 抽象类的注释说明</p>
<ol>
<li>AbstractQueuedSynchronizer 提供了一个框架，用来实现blocking locks 和 一些同步器，且是基于一个FIFO队列的</li>
<li>AbstractQueuedSynchronizer 被设计为使用一个<code>single atomic {@code int} value</code>来表示状态</li>
<li>AbstractQueuedSynchronizer的子类必须去定义状态，并提供protected方法去操作状态：getState、setState以及compareAndSet</li>
<li>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态</li>
</ol>
<h3 id="_2">阻塞</h3>
<p>j.u.c包有一个LockSuport类，这个类中包含了解决这个问题的方法。方法<code>LockSupport.park</code>阻塞当前线程除非/直到有个<code>LockSupport.unpark</code>方法被调用（unpark方法被提前调用也是可以的）。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可能有“剩余的”unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地消除这个状态但并不值得这样做。在需要的时候多次调用park会更高效。</p>
<p><strong>park</strong>: n. 公园; 专用区; 园区; (英国) 庄园，庭院; v. 停(车); 泊(车); 坐下(或站着); 把…搁置，推迟(在以后的会议上讨论或处理);</p>
<h3 id="fifoclh">FIFO队列(CLH 队列，双向链表)</h3>
<p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的FIFO队列，因此，框架不支持基于优先级的同步。</p>
<p>自旋判断前驱节点是否释放了锁：如去前驱没有释放锁，那么就一直自旋；否则就能获取到锁，结束自旋</p>
<div class="hlcode"><pre><span class="cm">/**</span>
<span class="cm">    * Creates and enqueues node for current thread and given mode.</span>
<span class="cm">    *</span>
<span class="cm">    * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span>
<span class="cm">    * @return the new node</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="n">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
    <span class="c1">// 将该线程节点加入到队列的尾部,头尾指针变化</span>
    <span class="c1">// Try the fast path of enq; backup to full enq on failure</span>
    <span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm">    * Inserts node into queue, initializing if necessary. See picture above.</span>
<span class="cm">    * @param node the node to insert</span>
<span class="cm">    * @return node&#39;s predecessor</span>
<span class="cm">    */</span>
<span class="kd">private</span> <span class="n">Node</span> <span class="nf">enq</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Must initialize</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetHead</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">()))</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>通过<code>自旋</code>(CAS操作)来保证该节点能顺利的加入到队列尾部，只有加入成功才会退出循环，否则会一直自旋直到成功。</p>
<h3 id="abstractqueuedsynchronizerlock">自己实现AbstractQueuedSynchronizer抽象类和Lock接口</h3>
<div class="hlcode"><pre><span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="o">{</span>
    <span class="c1">// Reports whether in locked</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// status 为0能获取锁；自旋设置为1，表示获取到锁了</span>
    <span class="c1">// Acquires the lock if state is zero</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="n">acquires</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Otherwise unused</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 释放锁，要把状态设置为0</span>
    <span class="c1">// Releases the lock by setting state to zero</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="n">releases</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Otherwise unused</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getState</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">setState</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Provides a Condition</span>
    <span class="n">Condition</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ConditionObject</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Deserializes properly</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">defaultReadObject</span><span class="o">();</span>
        <span class="n">setState</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// reset to unlocked state</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">SelfLock</span> <span class="kd">implements</span> <span class="n">Lock</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sync</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockInterruptibly</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">acquireInterruptibly</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">time</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireNanos</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">time</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Condition</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 doctording.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-06-18 09:23:40</p>
      </span>
    </div>

    
    
  </body>
</html>