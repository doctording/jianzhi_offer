---
title: "Java nio"
layout: page
date: 2019-04-07 00:00
---

[TOC]

# NIO

参考: <a href='https://howtodoinjava.com/java-nio-tutorials/'>java-nio-tutorials</a>

Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

## NIO API 的抽象

### 缓冲区 Buffer

* ByteBuffer
* MappedByteBuffer
* CharBuffer
* DoubleBuffer
* FloatBuffer
* IntBuffer
* LongBuffer
* ShortBuffer
* ByteOrder

它们是数据容器

### 字符集及其相关解码器 和编码器

它们在字节和Unicode字符之间进行转换

### 通道 Channel

Channel是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流，而且他们面向缓冲区的。

通道与流的不同之处在于`通道是双向`的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道 可以用于读、写或者同时用于读写。

通道可以以阻塞(blocking)或非阻塞(nonblocking)模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成,要么返回一个结果表明未进行任何操作。只有面向流的(stream-oriented)的通道,如 sockets 和 pipes 才能使用非阻塞模式。

![](https://raw.githubusercontent.com/doctording/sword_at_offer/master/content/java_io_net/imgs/buffer_channel.png)

### Selector

Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。

这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。

## NIO与IO的区别

* NIO是以`块`的方式处理数据，但是IO是以最基础的字节流的形式去写入和读出的。所以在效率上的话，肯定是NIO效率比IO效率会高出很多。

* NIO不在是和IO一样用OutputStream和InputStream输入流的形式来进行处理数据的，但是又是基于这种流的形式，而是采用了通道和缓冲区的形式来进行处理数据的。还有一点就是NIO的通道是可以`双向`的，但是IO中的流只能是单向的。

* NIO的缓冲区（其实也就是一个字节数组）还可以进行`分片`，可以建立只读缓冲区、直接缓冲区和间接缓冲区，只读缓冲区很明显就是字面意思，直接缓冲区是为加快I/O速度，而以一种特殊的方式分配其内存的缓冲区。

## Scatter/Gather

scatter/gather指的在多个缓冲区上实现一个简单的I/O操作，比如从通道中读取数据到多个缓冲区，或从多个缓冲区中写入数据到通道；

* scatter（分散）：指的是从通道中读取数据分散到多个缓冲区Buffer的过程，该过程会将每个缓存区填满，直至通道中无数据或缓冲区没有空间；

* gather（聚集）：指的是将多个缓冲区Buffer聚集起来写入到通道的过程，该过程类似于将多个缓冲区的内容连接起来写入通道；

## 缓冲区Buffer

### 属性信息

* 容量(Capacity): 缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。

* 上界(Limit): 缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。

* 位置(Position): 下一个要被读或写的元素的索引。位置会自动由相应的`get()`和`put()`函数更新。

* 标记(Mark): 一个备忘位置。调用`mark()`来设定mark=postion。调用`reset()`设定position=mark。标记在设定前是未定义的(undefined)

`0 <= mark <= position <= limit <= capacity`

### 非线程安全

缓冲区并不是线程安全的。如果您想以多线程同时存取特定的缓冲区，您需要在存取缓冲区之前进行同步(例如对缓冲区对象进行跟踪)

### 两个缓冲区被认为相等的充要条件

* 两个对象类型相同。包含不同数据类型的buffer永远不会相等，而且buffer 绝不会等于非 buffer 对象。

* 两个对象都剩余同样数量的元素。Buffer 的容量不需要相同，而且缓冲区中剩 余数据的索引也不必相同。但每个缓冲区中剩余元素的数目(从位置到上界)必须相同。

* 在每个缓冲区中应被Get()函数返回的剩余数据元素序列必须一致。

### 直接缓冲区 & 非直接缓冲区

参考1: https://blog.csdn.net/zhangxiaoyang0/article/details/79208249/

* 直接缓冲区：通过`allocateDirect()`方法分配直接缓冲区，将缓冲区建立在物理内存中(内存映射文件)

直接字节缓冲区通过调用`allocateDirect()`工厂方法来创建,此方法返回的缓冲区进行分配和取消分配所需成本通常**高于**非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。

直接字节缓冲区还可以通过`FileChannel`的`map()`方法,将文件区域直接映射到内存中来创建。该方法返回`MappedByteBuffer`。Java 平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。

* 非直接缓冲区： 通过`allocate()`方法分配缓冲区，将缓冲区建立在 JVM 的内存中
