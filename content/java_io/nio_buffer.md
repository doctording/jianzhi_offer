---
title: "Java nio 缓冲区"
layout: page
date: 2019-03-18 00:00
---

[TOC]

# 缓冲区Buffer

## 属性信息

* 容量(Capacity): 缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。

* 上界(Limit): 缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。

* 位置(Position): 下一个要被读或写的元素的索引。位置会自动由相应的`get()`和`put()`函数更新。

* 标记(Mark): 一个备忘位置。调用`mark()`来设定mark=postion。调用`reset()`设定position=mark。标记在设定前是未定义的(undefined)

`0 <= mark <= position <= limit <= capacity`

## 非线程安全

缓冲区并不是线程安全的。如果您想以多线程同时存取特定的缓冲区，您需要在存取缓冲区之前进行同步(例如对缓冲区对象进行跟踪)

## 两个缓冲区被认为相等的充要条件

* 两个对象类型相同。包含不同数据类型的buffer永远不会相等，而且buffer 绝不会等于非 buffer 对象。

* 两个对象都剩余同样数量的元素。Buffer 的容量不需要相同，而且缓冲区中剩 余数据的索引也不必相同。但每个缓冲区中剩余元素的数目(从位置到上界)必须相同。

* 在每个缓冲区中应被Get()函数返回的剩余数据元素序列必须一致。

## 直接缓冲区 & 非直接缓冲区

参考1: https://blog.csdn.net/zhangxiaoyang0/article/details/79208249/

* 直接缓冲区：通过`allocateDirect()`方法分配直接缓冲区，将缓冲区建立在物理内存中(内存映射文件)

直接字节缓冲区通过调用`allocateDirect()`工厂方法来创建,此方法返回的缓冲区进行分配和取消分配所需成本通常**高于**非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。

直接字节缓冲区还可以通过`FileChannel`的`map()`方法,将文件区域直接映射到内存中来创建。该方法返回`MappedByteBuffer`。Java 平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。

* 非直接缓冲区： 通过`allocate()`方法分配缓冲区，将缓冲区建立在 JVM 的内存中
